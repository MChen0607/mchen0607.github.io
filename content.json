{"pages":[],"posts":[{"title":"剑指Offer 03.数组中重复的数字【哈希表、数组交换、排序】","text":"题目描述找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入：[2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 解题思路方法一:哈希表（Set） 使用哈希表来进行，遍历数组，询问哈希表是否存在num元素，如果存在返回重复数字num，否则将num加入到哈希表中 代码实现1234567891011public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int num : nums) { if (set.contains(num)) { return num; } else { set.add(num); } } return -1;} 复杂度分析 时间复杂度：O(n) 遍历整个数组 空间复杂度：O(n) 使用辅助空间Set。 方法二:交换数组位置 由于数组是0~n-1,这个范围恰巧可以与数组的下标一一对应，所以nums[i]的值为下标i的位置, 因此本身数组可以作为哈希表来进行使用。 遍历数组，当数组元素对应则进行下一轮，如果此时下标nums[i]的值为nums[i]，则表示有冲突，就意味着找到重复的值，返回即可。如果没有冲突，则将nums[i]的值交换到对应的位置上。 代码实现：1234567891011121314151617181920212223public int findRepeatNumber2(int[] nums) { int len = nums.length; int i = 0; while (i &lt; len) {//一直比较下标i位置的元素，只能下标i对应上了才i++。 System.out.println(i); if (nums[i] == i) { i++; continue; } if (nums[nums[i]] == nums[i]) { return nums[i]; } swap(nums, i, nums[i]); //System.out.println(Arrays.toString(nums));观察数组变换 } return -1;}//a,b为下标private void swap(int[] nums, int a, int b) { int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp;} 复杂度分析 时间复杂度：O(n) 遍历整个数组 空间复杂度：O(1) 原地算法。 方法三：排序 排序，比较相邻的元素是否相等 代码实现： 12345678910public static int findRepeatNumber3(int[] nums) { Arrays.sort(nums); int len=nums.length; for(int i=1;i&lt;len;i++){ if(nums[i]==nums[i-1]){ return nums[i]; } } return -1;} 复杂度分析 时间复杂度：O(nlogn) 排序算法O(nlogn) 空间复杂度：O(1) 原地算法。 注：思考，为什么不能利用方法二中的一一对应的关系来进行比较nums[i]==i来确定是否在对应的位置;答：反例[1,2,2,3,4,5] 如果是比较一一对应关系，那么返回的结果会是1,由于数组缺失元素，排序后不能保证元素一一对应关系。 资源《剑指offer》 https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/tong-de-si-xiang-by-liweiwei1419/","link":"/2021/03/25/03%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指 Offer 05. 替换空格【字符串】","text":"题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 解题思路 遍历整个字符串，遇到空格时，向StringBuilder对象 加入”%20”，其他情况正常加入即可。最后将结果转换成String对象 代码实现1234567891011public String replaceSpace(String s) { StringBuilder sb=new StringBuilder(); for(int i=0;i&lt;s.length();i++){ if(s.charAt(i)==' '){ sb.append(&quot;%20&quot;); }else{ sb.append(s.charAt(i)); } } return sb.toString();} 复杂度分析 时间复杂度 O(n) 空间复杂度 O(n) 资源https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/","link":"/2021/03/27/05%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"title":"剑指 Offer 06. 从尾到头打印链表【递归、遍历、辅助栈】","text":"题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 解题思路方法一：递归 用递归的方法将链表的值存储到ArrayList数组中，进而将ArrayList数组赋值给res结果数组。 代码实现12345678910111213public int[] reversePrint(ListNode head) { ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); recur(head,tmp); int[] res = new int[tmp.size()]; for(int i = 0; i &lt; res.length; i++) res[i] = tmp.get(i); return res; } void recur(ListNode head,ArrayList&lt;Integer&gt; tmp) { if(head == null) return; recur(head.next,tmp); tmp.add(head.val); } 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 方法二：两次遍历 先遍历一遍整个链表，计算出链表的长度。声明链表长度的数组res，再一次遍历链表，将链表值逆序存储到数组中。 代码实现1234567891011121314151617181920public int[] reversePrint2(ListNode head) { if(head==null){ return new int [0]; } int len=0; ListNode premmyHead=head; while (premmyHead!=null){ len++; premmyHead=premmyHead.next; } int []res=new int[len]; int i=1; premmyHead=head; while(premmyHead!=null){ res[len-i]=premmyHead.val; i++; premmyHead=premmyHead.next; } return res;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 方法三：辅助栈 遍历整个链表将值插入到栈中，遍历完链表后，将栈中元素出栈顺序存储到结果数组res中。 代码实现123456789101112public int[] reversePrint3(ListNode head) { Stack&lt;Integer&gt; stack =new Stack&lt;&gt;(); while(head!=null){ stack.push(head.val); head=head.next; } int []res=new int[stack.size()]; for(int i=0;i&lt;res.length;i++){ res[i]=stack.pop(); } return res;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资源https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-d/","link":"/2021/03/28/06%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"title":"剑指 Offer 10- I. 斐波那契数列","text":"剑指 Offer 10- I. 斐波那契数列题目写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：1 示例 2： 输入：n = 5输出：5 提示： 0 &lt;= n &lt;= 100 解题思路 根据斐波那契数列，我们可以利用两个变量来进行对数字赋值，来减少时间和空间上的开支。 代码实现1234567891011121314151617class Solution { public int fib(int n) { if(n==0){ return 0; } if(n==1){ return 1; } int a=0,b=1,res=0; for(int i=1;i&lt;n;i++){ res=(a+b)%1000000007; a=b; b=res; } return res; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof","link":"/2021/03/30/10-%20I%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"title":"剑指 Offer 07. 重建二叉树【递归、迭代】","text":"题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 12345 3 / \\9 20 / \\ 15 7 限制： 0 &lt;= 节点个数 &lt;= 5000 解题思路方法一：递归 根据前序和中序的关系进行遍历。 前序遍历的顺序：根结点，左孩子结点，右孩子结点 中序遍历的顺序：左孩子结点，根节点，右孩子结点 所有我们需要做的是：在中序遍历结果中找到根节点的所在位置，将中序遍历结果分为三部分（左，根，右）。 根据中序遍历结果的长度，进而可以把前序遍历结果也分为三个部分（根，左，右）。 递归调用，直到当前数组长度为0,返回结果。 代码实现123456789101112131415161718192021public TreeNode buildTree(int[] preorder, int[] inorder) { int preleft = 0, preright = preorder.length - 1; int inleft = 0, inright = inorder.length - 1; return createTree(preorder, inorder, preleft, preright, inleft, inright);}TreeNode createTree(int[] preorder, int[] inorder, int preleft, int preright, int inleft, int inright) { if (preleft &gt; preright || inleft &gt; inright) { return null; } TreeNode root = new TreeNode(preorder[preleft]); int inIndex = inleft; for (int i = inleft; i &lt;= inright; i++) { if (inorder[i] == preorder[preleft]) { inIndex = i; } } root.left = createTree(preorder, inorder, preleft + 1, preleft + inIndex - inleft, inleft, inIndex - 1); root.right = createTree(preorder, inorder, preleft + inIndex - inleft + 1, preright, inIndex + 1, inright); return root;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 递归调用为O(h),h为二叉树的高度、返回结果O(n).因为h&lt;n，所以总的空间复杂度为O(n). 方法二：递归+优化 在方法一的基础上，进行优化查找中序遍历中的根结点方法，利用map集合存储中序队列值与下标对应关系。 代码实现1234567891011121314151617181920Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();public TreeNode buildTree2(int[] preorder, int[] inorder) { int preleft = 0, preright = preorder.length - 1; int inleft = 0, inright = inorder.length - 1; for(int i=0;i&lt;inorder.length;i++){ map.put(inorder[i],i); } return createTree2(preorder, inorder, preleft, preright, inleft, inright);}TreeNode createTree2(int[] preorder, int[] inorder, int preleft, int preright, int inleft, int inright) { if (preleft &gt; preright || inleft &gt; inright) { return null; } TreeNode root = new TreeNode(preorder[preleft]); int inIndex=map.get(preorder[preleft]);//优化查找方式。 root.left = createTree(preorder, inorder, preleft + 1, preleft + inIndex - inleft, inleft, inIndex - 1); root.right = createTree(preorder, inorder, preleft + inIndex - inleft + 1, preright, inIndex + 1, inright); return root;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 递归调用为O(h),h为二叉树的高度、返回结果O(n).因为h&lt;n，所以总的空间复杂度为O(n). 方法三：迭代 我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；无论是哪一种情况，我们最后都将当前的节点入栈。 代码实现：1234567891011121314151617181920212223242526public TreeNode buildTree3(int[] preorder, int[] inorder) { if (preorder.length == 0 || preorder.length == 0) { return null; } TreeNode root = new TreeNode(preorder[0]); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();//辅助栈 stack.push(root); int inorderIndex = 0; for (int i = 1; i &lt; preorder.length; i++) { int preorderVal = preorder[i]; TreeNode node = stack.peek(); if (node.val != inorder[inorderIndex]) {//如果栈顶元素不为中序遍历指针的对应的值，那么当前的值就为栈顶元素的左孩子。 node.left = new TreeNode(preorderVal); stack.push(node.left); } else {//如果相等，那么就将栈顶元素（当前根结点）出栈，右移中序遍历指针，循环判断，直到值不相等或者栈空。 while (!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[inorderIndex]) { node = stack.pop(); inorderIndex++; } //那么当前的值就为最后一个出栈的栈顶元素（当前根节点）的右孩子。 node.right = new TreeNode(preorderVal); stack.push(node.right); } } return root;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 递归调用为O(h),h为二叉树的高度、返回结果O(n).因为h&lt;n，所以总的空间复杂度为O(n). 资源：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/","link":"/2021/03/28/07%20%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"剑指 Offer 09. 用两个栈实现队列【设计、栈】","text":"题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入：[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 提示： 1 &lt;= values &lt;= 10000最多会对 appendTail、deleteHead 进行 10000 次调用 代码实现 模拟，使用两个栈，第一个栈主要入栈，第二个栈用来出栈。 入栈操作：直接加入到第一个栈中。 出栈操作：先判断第二个栈中是否有元素，如果有直接出栈就好；如果没有，那么进而判断第一个栈是否有元素：如果有，将第一个栈中的元素依次出栈后入栈到第二栈中，然后再出栈返回结果；如果第一个栈中没有元素，表明两个栈都没有元素，返回-1. Stack类1234567891011121314151617181920212223242526class CQueue { Stack&lt;Integer&gt; stacka; Stack&lt;Integer&gt; stackb; public CQueue() { stacka=new Stack&lt;&gt;(); stackb=new Stack&lt;&gt;(); } public void appendTail(int value) { stacka.push(value); } public int deleteHead() { if(stackb.empty()){ while(!stacka.empty()){ stackb.push(stacka.pop()); } } if(!stackb.empty()){ return stackb.pop(); }else{ return -1; } }} 双端队列Deque 实现栈的功能 1234567891011121314151617181920212223242526class CQueue { Deque&lt;Integer&gt; stacka; Deque&lt;Integer&gt; stackb; public CQueue() { stacka=new LinkedList&lt;&gt;(); stackb=new LinkedList&lt;&gt;(); } public void appendTail(int value) { stacka.push(value); } public int deleteHead() { if(stackb.isEmpty()){ while(!stacka.isEmpty()){ stackb.push(stacka.pop()); } } if(!stackb.isEmpty()){ return stackb.pop(); }else{ return -1; } }} 复杂度分析 时间复杂度：出栈，入栈操作为 O(1) 空间复杂度: O(n) 使用了两个辅助栈 资源https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof","link":"/2021/03/29/09%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"title":"剑指 Offer 04. 二维数组中的查找【暴力、双指针】","text":"题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 解题思路方法一：暴力法 暴力解：直接双重循环遍历二维数组。 代码实现1234567891011121314public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length == 0 || matrix[0].length == 0) { return false; } int m = matrix.length; int n = matrix[0].length; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (matrix[i][j] == target) return true; } } return false;} 复杂度分析 时间复杂度 O(mn) 双重循环 空间复杂度 O(1) 方法二：双指针 矩阵中神奇的发现，选择矩阵后可得到二叉排序树。 线性查找，将矩阵旋转可得到 二叉排序树，左孩子结点小于根节点，右节点大于根节点。 利用这个规律： 初始化起点：矩阵左上角点(0,n-1)。 如果结点值 等于 target : return true 如果结点值 大于 target ：列数减一 如果结点值 小于 target : 行数加一 代码实现123456789101112131415161718public boolean findNumberIn2DArray2(int[][] matrix, int target) { if(matrix==null||matrix.length==0||matrix[0].length==0){ return false; } int m=matrix.length; int n=matrix[0].length; int i=0,j=n-1; while(i&lt;m&amp;&amp;j&gt;=0){ if(matrix[i][j]==target){ return true; }else if(matrix[i][j]&gt;target){ j--; }else{ i++; } } return false;} 复杂度分析 时间复杂度O(m+n) 最差情况，从矩阵右上角到左下角。 空间复杂度O(1) 资源题目：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/ 题解：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/ 题解：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/","link":"/2021/03/26/04%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"title":"剑指 Offer 11. 旋转数组的最小数字【二分查找】","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2]输出：1 示例 2： 输入：[2,2,2,0,1]输出：0 解题思路方法一：暴力 由于旋转数组的呈现状只有两种，一种为旋转后保存原样的数组形式，另一种为 数组可分为两段递增排序，其中中断点定义为最大值到最小值的中断。 所以直接遍历数组，查看数组中是否有出现中断现象（当前值小于上一个值），如果有，则当前值为最小值，如果没有出现该现象，则第一个元素为最小值。 代码实现1234567891011public int minArray(int[] numbers) { if(numbers==null){ return -1; } for(int i=1;i&lt;numbers.length;i++){ if(numbers[i]&lt;numbers[i-1]){ return numbers[i]; } } return numbers[0];} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 方法二：二分查找 二分查找，对方法一的优化，方法一遍历数组中间复杂度为O(n),使用二分查找的方法来查找中断点时间复杂度只需要O(logn)。 二分查找规则：以right元素为比较对象，根据旋转数组的规律进行比较。 mid元素&gt;right元素，则最小值一定存在于mid右部分。 mid元素&lt;right元素,则最小值一定存在于mid的左部分。 mid元素==right元素,无法判断存在于哪个部分，则移动right向左移动一位，不影响最后结果，如果right为最小值，mid也是最小值，所以移动right一位不影响结果。 代码实现1234567891011121314public int minArray2(int[] numbers) { int left=0,right=numbers.length-1; while(left&lt;right){ int mid=left+(right-left)/2; if(numbers[mid]&lt;numbers[right]){ right=mid; }else if(numbers[mid]&gt;numbers[right]){ left=mid+1; }else{ right-=1; } } return numbers[left];} 复杂度分析 时间复杂度：O(log n) 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof","link":"/2021/03/30/11%20%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"title":"剑指 Offer 10- II. 青蛙跳台阶问题【DP】","text":"题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2输出：2 示例 2： 输入：n = 7输出：21 示例 3： 输入：n = 0输出：1 提示： 0 &lt;= n &lt;= 100 解题思路 仔细阅读后，我们会发现，当n&gt;1是，青蛙是可以从n-1级和n-2级跳上来的。也就是说： 跳到第n级台阶的跳法数就是=跳到第n-1级台阶的跳法数+跳到第n-2级台阶的跳法数 那么我们再注意下，第0级、第1级的次数，我们就能解决这道题了。 根据题目实例可知，跳到第0级有1种方法，第1级台阶也为1种办法。 这和斐波那契（Fibonacci）数列是一样的结果。 代码实现1234567891011class Solution { public int numWays(int n) { int a=0,b=1,res=1; for(int i=1;i&lt;=n;i++){ res=(a+b)%1000000007; a=b; b=res; } return res; }} 复杂度分析 时间复杂度: O(n) 空间复杂度: O(1) 资源https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof","link":"/2021/03/30/10-%E2%85%A1%20%20%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"title":"剑指 Offer14-Ⅰ 剪绳子【数学】","text":"题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 58 解题思路 通过数学公式求导推理可以得出，在分段的过程中，尽可能让每段都为3的情况下，乘积是最大的。 具体证明过程见资源链接。 代码实现12345678910111213141516static class Solution14_1 { public int cuttingRope(int n) { if(n&lt;2){ return 0; } if(n&lt;=3){ return n-1; } int times=n/3; if(n-times*3==1){//当分完数为3的times段后，还剩1时，会发现 1 3的乘积小于2 2的乘积，所以此情况需要减少一次分为3的段。 times--; } int mod=(n-times*3)/2;//当余数为0时 乘以1;余数为4时,乘以4;余数为2时乘以2.可转换为取2的（余数除以2）次方。 return (int)Math.pow(3,times)*(int)Math.pow(2,mod); }} 复杂性分析 时间复杂度: O(1) 空间复杂度：O(1) 资源证明过程：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/ https://leetcode-cn.com/problems/jian-sheng-zi-lcof/","link":"/2021/04/11/14-%E2%85%A0-%E5%89%AA%E7%BB%B3%E5%AD%90/"},{"title":"剑指 Offer 12. 矩阵中的路径【DFS】","text":"题目描述给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 &quot;ABCCED&quot;（单词中的字母已标出）。 示例 1： 输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”输出：true 示例 2： 输入：board = [[“a”,”b”],[“c”,”d”]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 2001 &lt;= board[i].length &lt;= 200board 和 word 仅由大小写英文字母组成 解题思路 利用深度优先搜索的方式进行，判断当前位置东南西北方向未访问的点的位置是否和下个字符串相同，如果有一个方向符合要求，那么就朝这个方向继续进行搜索。对不符合要求的方向进行剪枝操作。 其中运用回溯的思想进行对不符合要求的路径进行结点访问情况恢复。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static class Solution12 { int x[] = new int[]{0, 1, 0, -1}; int y[] = new int[]{1, 0, -1, 0}; public boolean exist(char[][] board, String word) { if (board.length == 0 || board[0].length == 0) { return false; } char[] arrayWord = word.toCharArray(); int m = board.length; int n = board[0].length; boolean[][] visited = new boolean[m][n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (board[i][j] == arrayWord[0]) { visited[i][j] = true; if (dfs(board, arrayWord, i, j, m, n, 1, visited)) { return true; } visited[i][j] = false; } } } return false; } private boolean dfs(char[][] board, char[] arrayWord, int i, int j, int m, int n, int index, boolean[][] visited) { if (index == arrayWord.length) { return true; } int indexI = i, indexY = j; boolean findPath = false; for (int k = 0; k &lt; 4; k++) { indexI = i + x[k]; indexY = j + y[k]; if (indexI &gt;= 0 &amp;&amp; indexI &lt; m &amp;&amp; indexY &gt;= 0 &amp;&amp; indexY &lt; n &amp;&amp; !visited[indexI][indexY] &amp;&amp; board[indexI][indexY] == arrayWord[index]) {//剪枝 visited[indexI][indexY] = true; findPath = dfs(board, arrayWord, indexI, indexY, m, n, index + 1, visited); if (findPath) { return true; } else { visited[indexI][indexY] = false; } } } return findPath; }} 复杂度分析 注：复杂度分析参考官方题解。 时间复杂度：O($3^{length} MN$) ，length为查找字符串长度。 空间复杂度：O(MN) ，visited数组使用的空间 资源https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/ https://leetcode-cn.com/problems/word-search/solution/dan-ci-sou-suo-by-leetcode-solution/","link":"/2021/04/10/12%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"剑指 Offer14-Ⅱ 剪绳子Ⅱ【快速幂、数学】","text":"题目描述给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 提示： 2 &lt;= n &lt;= 1000 解题思路 基本思路同14-Ⅰ剪绳子是一样的，通过数学公式求导推理可以得出，在分段的过程中，尽可能让每段都为3的情况下，乘积是最大的。 由于此题的N较大，会出现大数情况，所以对求解3的times次方采用快速幂的方式进行求解。 代码实现1234567891011121314151617181920static class Solution14_2 { public int cuttingRope(int n) { if(n&lt;=3){ return n-1; } long res=1; long x=3; int times=n/3; if(n-times*3==1){//当分完数为3的times段后，还剩1时，会发现 1 3的乘积小于2 2的乘积，所以此情况需要减少一次分为3的段。 times--; } int mod=(n-times*3)/2; while(times!=0){//快速幂 res=(times&amp;1)==1?(res*x)%1000000007:res; times/=2; x=x*x%1000000007; } return (int)(res*Math.pow(2,mod)%1000000007); }} 复杂度分析 时间复杂度：O(log2t) t为times 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof","link":"/2021/04/11/14-%E2%85%A1-%E5%89%AA%E7%BB%B3%E5%AD%90%E2%85%A1/"},{"title":"剑指 Offer 13. 机器人的运动范围【DFS】","text":"题目描述地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1输出：3 示例 2： 输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 1000 &lt;= k &lt;= 20 解题思路 本题思路和剑指offer 12.矩阵的路径是一样的，采用深度优先搜索策略。 只是在剪枝判断过程时，增加结点的数位之后是否小于K(18)。其他思路大致相同。 代码实现12345678910111213141516171819202122232425262728static class Solution13 { public int movingCount(int m, int n, int k) { if (m == 0 || n == 0) { return 0; } boolean[][] visited = new boolean[m][n]; int count = dfs(m, n, k, 0, 0, visited); return count; } private int dfs(int m, int n, int k, int indexI, int indexJ, boolean[][] visited) { int count=0; if(indexI&gt;=0&amp;&amp;indexI&lt;m&amp;&amp;indexJ&gt;=0&amp;&amp;indexJ&lt;n&amp;&amp;!visited[indexI][indexJ]&amp;&amp;getSum(indexI)+getSum(indexJ)&lt;=k){//indexI、indexJ一定是 &gt;=0的,剪枝。 visited[indexI][indexJ]=true; count=1+dfs(m,n,k,indexI+1,indexJ,visited)+dfs(m,n,k,indexI,indexJ+1,visited); } return count; } private int getSum(int n) { int sum=0; while(n!=0){ sum+=n%10; n=n/10; } return sum; }} 复杂度分析 时间复杂度：O(MN) 空间复杂度：O(MN) 资源https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof","link":"/2021/04/10/13%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"title":"剑指 Offer 15. 二进制中1的个数【位运算】","text":"题目描述请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。 示例 2： 输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。 示例 3： 输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。 提示： 输入必须是长度为 32 的 二进制串 。 解题思路方法一:暴力 直接遍历,将n转为32位2进制，计算出1的个数 代码实现123456789public int hammingWeight(int n) { int res=0; while(n!=0){ if((n&amp;1)==1) res++; n &gt;&gt;&gt;= 1; } return res;} 复杂度分析 时间复杂度：O(32) 32位二进制 空间复杂度：O(1) 方法二：位运算 利用位运算的规律，n=n&amp;(n-1)公式可以将n的二进制数中的最后一位1变为0;比如 n=00011100 n-1=00011011 n&amp;(n-1)=00011000.利用此公式可以减少循环的次数，降低为1的次数。时间复杂度为 O(m) m为n中1的个数。 代码实现12345678public int hammingWeight1(int n) { int res=0; while(n!=0){ res++; n=n&amp;(n-1); } return res;} 复杂度分析 时间复杂度：O(m) m《 32 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof","link":"/2021/04/11/15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"剑指offer19 正则表达式","text":"题目描述请实现一个函数用来匹配包含'.'和’*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 示例 2: 输入:s = “aa”p = “a*”输出: true解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。 示例 3: 输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个（’*’）任意字符（’.’）。 示例 4: 输入:s = “aab”p = “cab”输出: true解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。 示例 5: 输入:s = “mississippi”p = “misisp*.”输出: falses 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 ，无连续的 ‘‘。 解题思路方法：有待完善资源https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof","link":"/2021/04/16/19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"剑指 Offer 20. 表示数值的字符串【字符串】","text":"题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 解题思路 根据字符设置不同的状态，进行状态间的转换和判断。 代码123456789101112131415161718192021222324252627282930static class Solution20 { public boolean isNumber(String s) { if (s.length() == 0) { return false; } s = s.trim();//先去除字符串前后的空格 boolean numFlag = false; boolean opsFlag = false; boolean eFlag = false; boolean dotFlag = false; for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if (c &gt;= '0' &amp;&amp; c &lt;= '9') { numFlag = true; } else if (c == '.' &amp;&amp; !eFlag &amp;&amp; !dotFlag) {//e后面不能有'.' dotFlag = true; } else if ((c == '+' || c == '-') &amp;&amp; !opsFlag &amp;&amp; (i == 0 || s.charAt(i - 1) == 'e' || s.charAt(i - 1) == 'E')) { //只能有一个'+'/'-';获取前一个字符为'e'/'E'; opsFlag = true; } else if ((c == 'e' || c == 'E') &amp;&amp; !eFlag &amp;&amp; numFlag) {//e前面至少要有一个数组出现。 eFlag = true;// 合格的数字只能有一个e opsFlag = false;// 允许e后面有一个'+'/'-' numFlag = false;// e后面一定要有 数字 } else {//其他情况都为非法数字形式。 return false; } } return numFlag; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/","link":"/2021/04/16/20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"剑指 Offer 17. 打印从1到最大的n位数","text":"题目描述输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 解题思路方法一：暴力法 直接声明相对应的空间的数组，通过对值直接+1的方式赋值。 代码12345678public int[] printNumbers(int n) { int len = (int) Math.pow(10, n) - 1; int[] num = new int[len]; for (int i = 0; i &lt; len; i++) { num[i] = i + 1; } return num;} 复杂度分析 时间复杂度: O($10^n$) 空间复杂度: O($10^n$) 缺点分析 此暴力法可以处理n较小的情况，当n较大时，此方法的性能就比较差，需要使用其他的方法来进行对N较大时求解。 方法二：有待完善资源https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof","link":"/2021/04/16/17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"},{"title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面【双指针】","text":"题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 123输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示： 0 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10000 解题思路方法：双指针 双指针：left从左往右，right从右往左，分别找到偶数、奇数，交换两数的位置，直到left和right相遇为止，使得奇数都在偶数前面。 注：改变了奇数偶数的相对位置顺序。 代码实现12345678910111213141516171819202122232425class Solution21 { public int[] exchange(int[] nums) { int len=nums.length; if(len&lt;2){ return nums; } int left=0,right=len-1; while(left&lt;right){ while(left&lt;right&amp;&amp;(nums[left]&amp;1)==1){//找到偶数 left++; } while(right&gt;left&amp;&amp;(nums[right]&amp;1)==0){//找到奇数 right--; } if(left&lt;right){//交换位置 int temp=nums[right]; nums[right]=nums[left]; nums[left]=temp; left++; right--; } } return nums; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源 《剑指offer》 https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/","link":"/2021/04/19/21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"title":"剑指 Offer 16. 数值的整数次方【快速幂】","text":"题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入：x = 2.00000, n = 10输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3输出：9.26100 示例 3： 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 提示：【有问题】 -100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 解题思路快速幂 快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。 快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)。 代码实现1234567891011121314151617static class Solution16 { public double myPow(double x, int n) { if(x == 0) return 0; long b = n; double res = 1.0; if(b &lt; 0) { x = 1 / x; b = -b; } while(b &gt; 0) { if((b &amp; 1) == 1) res *= x; x *= x; b &gt;&gt;= 1; } return res; }} 复杂度分析 时间复杂度：O(log n) 空间复杂度：O(1) 资源https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof","link":"/2021/04/11/16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"title":"剑指 Offer 18. 删除链表的节点【快慢指针】","text":"题目描述给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例 1: 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明： 题目保证链表中节点的值互不相同 解题思路方法：双指针[快慢指针] 使用双指针的方式，cur指向当前结点，pre指向当前结点的前一个结点，一次遍历链表即可。 代码12345678910111213141516171819202122232425class Solution { public ListNode deleteNode(ListNode head, int val) { // 如果链表为空，则直接返回null结点。 if(head==null){ return null; } // 如果要删除的结点就是头结点，可直接返回头结点的next指针。 if(head.val==val){ return head.next; } // 如果不为以上两种情况，则使用双指针的方式进行对链表的删除结点任务 // pre记为要删除结点的前一个指针，cur为当前遍历的指针。 // 循环遍历直到cur为null. ListNode pre=head,cur=head.next; while(cur!=null){ if(cur.val==val){// 如果找到要删除的结点，则将当前的next指针赋值给pre的next指针，完成删除工作。 pre.next=cur.next; return head; } pre=cur; cur=cur.next; } return head;//如果没找要删除的结点，则返回head结点即可。 }} 复杂度分析 时间复杂度：O(n) //链表一轮遍历 空间复杂度：O(1) //只使用了 pre 、cur指针 资源https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof","link":"/2021/04/16/18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"剑指 Offer 24. 反转链表【递归、迭代】","text":"题目描述定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制： 10 &lt;= 节点个数 &lt;= 5000 解题思路方法一：迭代 迭代法：定义一个伪头部，遍历head链表，使用头插法插入到伪头部链表中，最后返回虚拟头部的next指针即可。 代码实现1234567891011public ListNode reverseList(ListNode head) { ListNode dummyHead = new ListNode(-1); dummyHead.next = null; while (head != null) { ListNode next = head.next; head.next = dummyHead.next; dummyHead.next = head; head = next; } return dummyHead.next;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 方法二：递归 递归调用，修改结点的指针转向。 代码实现123456789public ListNode reverseList2(ListNode head) { if (head == null||head.next==null) { return head; } ListNode newHead = reverseList2(head.next); head.next.next=head;//指针转向 head.next=null; return newHead;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) //递归调用栈使用。 资源 https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/ https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/","link":"/2021/04/19/24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"剑指 Offer 22. 链表中倒数第k个节点【快慢指针】","text":"题目描述输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5. 解题思路方法：双指针[快慢指针] 双指针，使用快慢指针进行，快指针post先走K步后，慢指针cur同快指针post一同向前走，直到快指针走到尽头，此时慢指针就是倒数第K个指针。 代码实现123456789101112// 假设此方法 k 是有效的，解决本题足以。public ListNode getKthFromEnd(ListNode head, int k) { ListNode post = head, cur = head; for (int i = 0; i &lt; k; i++) { post = post.next; } while (post != null) { cur = cur.next; post = post.next; } return cur;} 12345678910111213141516171819202122232425// 假设此方法 k 是任意数// 先计算链表长度，判断k是否有效public ListNode getKthFromEnd2(ListNode head, int k) { if (k &lt; 1) { //本题从1开始 return null; } int len = 0; ListNode dummyHead = head; while (dummyHead != null) {//计算链表的长度 len++; dummyHead = dummyHead.next; } if (k &lt; 1 || k &gt; len) { //k超出1~len的范围为无效范围 return null; } ListNode post = head, cur = head; for (int i = 0; i &lt; k; i++) { post = post.next; } while (post != null) { cur = cur.next; post = post.next; } return cur;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源 https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ 《剑指offer》","link":"/2021/04/19/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"剑指 Offer 25. 合并两个排序的链表【递归、迭代】","text":"题目描述输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 限制： 10 &lt;= 链表长度 &lt;= 1000 解题思路方法一：迭代 使用伪头结点，比较两个链表，将值小的链条通过尾插入法 插入到伪结点的链表中，直到其中一方结束，接着将不为空的一方直接加入到伪结点的链表的尾部。 代码实现123456789101112131415161718public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummyHead=new ListNode(-1); ListNode cur=dummyHead; while(l1!=null&amp;&amp;l2!=null){ if(l1.val&lt;= l2.val){ cur.next=l1; l1=l1.next; }else{ cur.next=l2; l2=l2.next; } cur=cur.next; } cur.next=l1==null?l2:l1; return dummyHead.next;} 复杂度分析 时间复杂度：O(m+n) 空间复杂度：O(1) 方法二：递归代码实现1234567891011121314151617public ListNode mergeTwoLists2(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } if(l2==null){ return l1; } ListNode res=null; if (l1.val &lt;= l2.val) { res=l1; res.next=mergeTwoLists2(l1.next,l2); } else { res=l2; res.next=mergeTwoLists2(l1,l2.next); } return res;} 复杂度分析 时间复杂度：O(m+n) 空间复杂度：O(n+m) //递归调用栈 资源 https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/ 《剑指offer》","link":"/2021/04/19/25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"title":"剑指 Offer 27. 二叉树的镜像【递归、迭代】","text":"题目描述请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： ​ 4 ​ / \\ ​ 2 7 / \\ / \\ 1 3 6 9镜像输出： ​ 4 ​ / \\ ​ 7 2 / \\ / \\ 9 6 3 1 示例 1： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 解题思路方法一：递归代码实现1234567891011public TreeNode mirrorTree(TreeNode root) { if (root == null) { return null; } // 先记录下root的左右孩子结点，再进行递归调用 TreeNode left = root.left; TreeNode right = root.right; root.left = mirrorTree(right); root.right = mirrorTree(left); return root;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 方法二：迭代 将未交换的结点存入栈中，将交换的结点的孩子节点存入栈，使得每个结点都交换左右孩子结点即可。 代码实现1234567891011121314151617181920public TreeNode mirrorTree2(TreeNode root) { if (root == null) { return null; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.add(root); while (!stack.isEmpty()) { TreeNode node = stack.pop(); if (node.left != null) { stack.add(node.left); } if (node.right != null) { stack.add(node.right); } TreeNode temp = node.left; node.left = node.right; node.right = temp; } return root;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资源 https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/ 《剑指offer》","link":"/2021/04/19/27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"title":"剑指 Offer 26. 树的子结构【迭代】","text":"题目描述输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: ​ 3 ​ / \\ ​ 4 5 / \\ 1 2给定的树 B： 4 / 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 12输入：A = [1,2,3], B = [3,1]输出：false 示例 2： 12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 10 &lt;= 节点个数 &lt;= 10000 解题思路方法一：迭代 步骤一：首先在A中找到等于B头结点值的结点，如果存在，则进行继续判断子结点是否全部一致； 步骤二：如果前面判断结果为false,则进行对当前结点的左右孩子进行搜索，搜索步骤同“步骤一”一致。 代码实现1234567891011121314151617181920212223242526272829class Solution26 { public boolean isSubStructure(TreeNode A, TreeNode B) { if (B == null || A == null) { return false; } boolean res = false; if (A.val == B.val) {//A的当前结点为B的结点，则进行向下判断子结点是否一致 res = subStructure(A.left, B.left) &amp;&amp; subStructure(A.right, B.right); } if (!res) {// 如果A的当前结点不包含B的树结构，则进行搜索A的左右孩子结点 res = isSubStructure(A.left, B) || isSubStructure(A.right, B); } return res; } public boolean subStructure(TreeNode A, TreeNode B) { if (B == null) { return true; } if (A == null) { //B不为null return false; } if (A.val != B.val) { return false; } return subStructure(A.left, B.left) &amp;&amp; subStructure(A.right, B.right); }} 复杂度分析 时间复杂度：O(MN) //其中 M,N分别为树 A 和 树 B的节点数量空间复杂度：O(M) //树A的深度高度 资源 https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/ 复杂度分析：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/","link":"/2021/04/19/26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"title":"剑指 Offer 28. 对称的二叉树【递归】","text":"题目描述请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 ​ 1 ​ / \\ ​ 2 2 ​ / \\ / \\ ​ 3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: ​ 1 ​ / \\ ​ 2 2 ​ \\ \\ ​ 3 3 示例 1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例 2： 12输入：root = [1,2,2,null,3,null,3]输出：false 解题思路方法：递归 递归判断对称结点是否值相等 代码实现12345678910111213141516171819202122class Solution28 { public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return Symmetric(root.left, root.right); } public boolean Symmetric(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } if (left == null || right == null) { return false; } if (left.val != right.val) { return true; } return Symmetric(left.right, right.left) &amp;&amp; Symmetric(left.left, right.right); }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) //递归调用栈使用。 资源 https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/ 《剑指offer》","link":"/2021/04/19/28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"LFU缓存结构设计","text":"描述一个缓存结构需要实现如下功能。 set(key, value)：将记录(key, value)插入该结构 get(key)：返回key对应的value值 但是缓存结构中最多放K条记录，如果新的第K+1条记录要加入，就需要根据策略删掉一条记录，然后才能把新记录加入。这个策略为：在缓存结构的K条记录中，哪一个key从进入缓存结构的时刻开始，被调用set或者get的次数最少，就删掉这个key的记录； 如果调用次数最少的key有多个，上次调用发生最早的key被删除 这就是LFU缓存替换算法。实现这个结构，K作为参数给出 [要求] set和get方法的时间复杂度为O(1) 若opt=1，接下来两个整数x, y，表示set(x, y)若opt=2，接下来一个整数x，表示get(x)，若x未出现过或已被移除，则返回-1 对于每个操作2，输出一个答案 示例1输入： 1[[1,1,1],[1,2,2],[1,3,2],[1,2,4],[1,3,5],[2,2],[1,4,4],[2,1]],3 返回值： 1[4,-1] 说明：在执行”1 2 4”后，”1 1 1”被删除。因此第二次询问的答案为-1 备注：$1 \\leq k \\leq n \\leq 10^5$ $-2 \\times 10^9 \\leq x,y \\leq 2 \\times 10^9$ import java.util.*; public class Solution { /** * lfu design * @param operators int整型二维数组 ops * @param k int整型 the k * @return int整型一维数组 */ class LFUCache{ class Node{ int k; int val; int freq; public Node(){} public Node(int k, int val, int freq){ this.k = k; this.val = val; this.freq = freq; } } private int capacity; private Map&lt;Integer, Node&gt; map = new HashMap&lt;&gt;(); private Map&lt;Integer, LinkedList&lt;Node&gt;&gt; freqMap = new HashMap&lt;&gt;(); private int minFreq; public LFUCache(int capacity){ this.capacity = capacity; this.minFreq = 1; } public void update(Node node){ LinkedList&lt;Node&gt; list = freqMap.get(node.freq); list.remove(node); if (list.isEmpty() &amp;&amp; node.freq == minFreq){ minFreq++; } node.freq++; if (!freqMap.containsKey(node.freq)){ freqMap.put(node.freq, new LinkedList&lt;&gt;()); } freqMap.get(node.freq).addLast(node); } public int get(int k){ if (!map.containsKey(k)){ return -1; } Node node = map.get(k); update(node); return node.val; } public void put(int k, int val){ if (map.containsKey(k)){ Node node = map.get(k); node.val = val; update(node); map.put(k, node); return; } if (map.size() == capacity){ Node node = freqMap.get(minFreq).removeFirst(); map.remove(node.k); } Node node = new Node(k, val, 1); map.put(k, node); if (!freqMap.containsKey(1)){ freqMap.put(1, new LinkedList&lt;&gt;()); } freqMap.get(1).addLast(node); minFreq = 1; } } public int[] LFU (int[][] operators, int k) { // write code here LFUCache cache = new LFUCache(k); ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; operators.length; i++){ if (operators[i][0] == 1){ cache.put(operators[i][1], operators[i][2]); }else{ res.add(cache.get(operators[i][1])); } } int[] ans = new int[res.size()]; for (int i = 0; i &lt; ans.length; i++){ ans[i] = res.get(i); } return ans; } }","link":"/2021/05/26/LFU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"NC35 最小编辑代价","text":"描述给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。 示例1输入： 1&quot;abc&quot;,&quot;adc&quot;,5,3,2 返回值： 12 示例2输入： 1&quot;abc&quot;,&quot;adc&quot;,5,3,100 返回值： 18 备注：$1 \\leq |str_1|, |str_2| \\leq 50001≤∣str1∣,∣str2∣≤5000$$1 \\leq ic, dc, rc \\leq 100001≤ic,dc,rc≤10000$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;public class Solution { /** * min edit cost * @param str1 string字符串 the string * @param str2 string字符串 the string * @param ic int整型 insert cost * @param dc int整型 delete cost * @param rc int整型 replace cost * @return int整型 */ public int minEditCost (String str1, String str2, int ic, int dc, int rc) { // write code here int n = str1.length(); int m = str2.length(); // 有一个字符串为空串 if (n * m == 0) { return Math.max(n,m)*Math.min(dc,rc); } // DP 数组 int[][] D = new int[n + 1][m + 1]; // 边界状态初始化 for (int i = 0; i &lt; n + 1; i++) { D[i][0] = i*dc; } for (int j = 0; j &lt; m + 1; j++) { D[0][j] = j*ic; } // 计算所有 DP 值 for (int i = 1; i &lt; n + 1; i++) { for (int j = 1; j &lt; m + 1; j++) { int left = D[i - 1][j] + dc; int down = D[i][j - 1] + ic; int left_down = D[i - 1][j - 1]; if (str1.charAt(i - 1) != str2.charAt(j - 1)) { left_down += rc; } D[i][j] = Math.min(left, Math.min(down, left_down)); } } return D[n][m]; }}","link":"/2021/05/26/NC35-%E6%9C%80%E5%B0%8F%E7%BC%96%E8%BE%91%E4%BB%A3%E4%BB%B7/"},{"title":"Leetcode72 编辑距离","text":"72. 编辑距离给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') 示例 2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int minDistance(String word1, String word2) { int n = word1.length(); int m = word2.length(); // 有一个字符串为空串 if (n * m == 0) { return n + m; } // DP 数组 int[][] D = new int[n + 1][m + 1]; // 边界状态初始化 for (int i = 0; i &lt; n + 1; i++) { D[i][0] = i; } for (int j = 0; j &lt; m + 1; j++) { D[0][j] = j; } // 计算所有 DP 值 for (int i = 1; i &lt; n + 1; i++) { for (int j = 1; j &lt; m + 1; j++) { int left = D[i - 1][j] + 1; int down = D[i][j - 1] + 1; int left_down = D[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) { left_down += 1; } D[i][j] = Math.min(left, Math.min(down, left_down)); } } return D[n][m]; }}作者：LeetCode-Solution链接：https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2021/05/26/Leetcode72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"},{"title":"前缀树","text":"前缀树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static class Trie { private Trie[] subNodes;//子结点 private boolean isEnd;//是否为字符串最后一个字符 // 初始化前缀树 public Trie() { this.subNodes = new Trie[26];//26个字符 this.isEnd = false; } // 插入字符到树中。 public void insert(String word) { Trie node = this; for (int i = 0; i &lt; word.length(); i++) { char c = word.charAt(i); int index = c - 'a'; if (node.subNodes[index] == null) { node.subNodes[index] = new Trie(); } node = node.subNodes[index]; } node.isEnd = true; } // 返回单词是否在trie中。 public boolean search(String word) { Trie node = searchPrefix(word); return node != null &amp;&amp; node.isEnd; } // 返回在trie中是否有以给定前缀开头的单词。 public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; } public Trie searchPrefix(String prefix) { Trie node = this; for (int i = 0; i &lt; prefix.length(); i++) { int index = prefix.charAt(i) - 'a'; if (node.subNodes[index] == null) { return null; } node = node.subNodes[index]; } return node; }}","link":"/2021/04/14/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"title":"剑指offer29 顺时针打印矩阵","text":"题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 解题思路方法一：矩阵 根据矩阵的大小来进行输出 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution29 { public int[] spiralOrder(int[][] matrix) { if (matrix.length == 0 || matrix[0].length == 0) { return new int[0]; } int rows = matrix.length, columns = matrix[0].length; int[] res = new int[rows * columns]; int index = 0; for (int i = 0; 2 * i &lt; columns &amp;&amp; 2 * i &lt; rows; i++) { index = order(matrix, rows - 1, columns - 1, i, res, index); } return res; } private int order(int[][] matrix, int rows, int columns, int start, int[] res, int index) { int endX = rows - start;//行 int endY = columns - start;//列 // 遍历矩阵四个方向， 向右，向下，向左，向上。 // 1.向右：一定存在 for (int i = start; i &lt;= endY; i++) { res[index++] = matrix[start][i]; } // 2.向下：需要有两行以上 if (endX &gt; start) { for (int i = start + 1; i &lt;= endX; i++) { res[index++] = matrix[i][endY]; } } // 3.向左，需要有两行两列以上 if (endX &gt; start &amp;&amp; endY &gt; start) { for (int i = endY - 1; i &gt;= start; i--) { res[index++] = matrix[endX][i]; } } // 4.向上，需要有三行两列以上 if (endX &gt; start + 1 &amp;&amp; endY &gt; start) { for (int i = endX - 1; i &gt; start; i--) { res[index++] = matrix[i][start]; } } return index; }} 资料https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"},{"title":"python基础","text":"python基础2020.10.7123456789101112131415161718192021222324252627282930313233r'xxx' ----xxx不发生转义 （'\\'转义字符）100000 ---等价于100_000,添加'_':'_'位置可以任意浮点数：1.23x10^9 1.23e9 1.23x10^-9 1.23e-9 （e可以大小写） '''...'''表示多行内容布尔值 True False （首字符大写）可进行 and、or、not运算空值None(不等于0，0有自己的意义)TODO可以创建自定义数据类型变量:同一个变量可以反复被赋值，可为不同数据类型a = 123 # a是整数print(a)a = 'ABC' # a变为字符串print(a)结果：123ABC常量;变量名默认为全部大写整数的运算结果永远是精确的，无论整数做//除法还是取余数，结果永远是整数10/5=2.010//5=210%3=1python的整数没有大小限制；浮点数也没有，但超出一定范围（贼大）就直接表示为inf（无限大） 字符串和编码： 123456789101112字符串：对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文'需要转义，用%%来表示一个%;","link":"/2021/03/24/python-base/"},{"title":"剑指offer30 包含min函数的栈","text":"题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过 20000 次 解题思路方法一：辅助栈 方法二：头插法链表方法实现12345678910111213141516171819202122232425262728293031323334353637383940class MinStack { Node head; /** initialize your data structure here. */ public MinStack() { } public void push(int x) { if (head == null) { head = new Node(null, x, x); } else { head = new Node(head, x, Math.min(head.min, x)); } } public void pop() { head = head.next; } public int top() { return head.val; } public int min() { return head.min; }}class Node { Node next; int val; int min; public Node(Node next, int val, int min) { this.next = next; this.val = val; this.min = min; }}","link":"/2021/05/28/%E5%89%91%E6%8C%87offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"title":"剑指offer32-Ⅱ 从上到下打印二叉树Ⅱ","text":"题目描述从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 提示： 节点总数 &lt;= 1000 解题思路方法一：队列 方法二：递归 代码实现12345678910111213141516171819class Solution32_2 { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); level(res, root, 0); return res; } private void level(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int level) { if (root == null) { return; } if (level &gt;= res.size()) { res.add(new ArrayList&lt;&gt;()); } res.get(level).add(root.val); level(res, root.left, level + 1); level(res, root.right, level + 1); }} 资料 https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer32-%E2%85%A1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/23/hello-world/"},{"title":"剑指offer32-Ⅲ 从上到下打印二叉树Ⅲ","text":"题目描述请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [20,9], [15,7]] 提示： 节点总数 &lt;= 1000 解题思路方法一：队列、广度优先搜索 方法二：递归 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution { /** * 递归 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); level(res, root, 0); return res; } private void level(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int level) { if (root == null) { return; } if (level &gt;= res.size()) { res.add(new LinkedList&lt;&gt;()); } if ((level &amp; 1) == 0) { res.get(level).add(root.val); } else { res.get(level).add(0, root.val); } level(res, root.left, level + 1); level(res, root.right, level + 1); } /** * 队列 迭代 * &lt;p&gt; * 多种方式，可以进行，只需对奇偶层逻辑进行处理后，对加入链表队列的方式有所不同就能达到目的效果 */ public List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) { return res; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); int level = 1; queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } if (level % 2 == 0) { //反转链表 Collections.reverse(list); } res.add(list); level++; } return res; }} 资料https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer32-%E2%85%A2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/"},{"title":"剑指offer33 二叉搜索树的后序遍历序列","text":"题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 12345 5 / \\ 2 6 / \\1 3 示例 1： 12输入: [1,6,3,2,5]输出: false 示例 2： 12输入: [1,3,2,6,5]输出: true 提示： 数组长度 &lt;= 1000 解题思路方法一：栈方法二：递归？？？1234567891011121314151617181920212223242526272829303132class Solution33 { // 递归调用 public boolean verifyPostorder(int[] postorder) { return recur(postorder, 0, postorder.length - 1); } boolean recur(int[] postorder, int i, int j) { if (i &gt;= j) return true; int p = i; while (postorder[p] &lt; postorder[j]) p++;//左子树部分 int m = p; while (postorder[p] &gt; postorder[j]) p++;//右子树部分 // 正常的后序遍历 左子树|右子树|根结点，经过遍历查找左子树和右子树后p会等于j，否则该序列不为搜索二叉树的后序遍历序列 return p == j &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1); } // 迭代：单调栈 public boolean verifyPostorder2(int[] postorder) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int root = Integer.MAX_VALUE; for (int i = postorder.length - 1; i &gt;= 0; i--) { if (postorder[i] &gt; root) { return false; } while (!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i]) { root = stack.pop(); } stack.push(postorder[i]); } return true; }} 资料 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"title":"剑指offer34 二叉树中和为某一值的路径","text":"题目描述输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例:给定如下二叉树，以及目标和 target = 22， 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 返回: 1234[ [5,4,11,2], [5,8,4,5]] 提示： 节点总数 &lt;= 10000 解题思路方法一：深度优先搜索代码实现1234567891011121314151617181920212223class Solution34 { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) { recur(root, target); return res; } void recur(TreeNode root, int target) { if (root == null) return; // if (target &lt; 0) {//剪枝 不能这么操作，本题没有设置结点的值大于0的限制。 // return; // } path.add(root.val); target -= root.val; if (target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add(new ArrayList&lt;&gt;(path)); recur(root.left, target); recur(root.right, target); path.remove(path.size() - 1); }} 资料 https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"title":"剑指offer35 复杂链表的复制","text":"题目描述请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例 3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例 4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 解题思路方法一：链表 资料 https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"title":"剑指offer36 二叉搜索树与双向链表","text":"题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 解题思路方法一：中序遍历代码实现123456789101112131415161718192021222324252627282930class Solution36 { Node pre, head; public Node treeToDoublyList(Node root) { if (root == null) { return null; } dfs(root); pre.right = head; head.left = pre; return head; } private void dfs(Node root) { if (root == null) { return; } dfs(root.left); if (pre != null) { pre.right = root; } else { // pre结点为空，则赋值head头结点 head = root; } root.left = pre; pre = root; System.out.println(pre.val); dfs(root.right); }} 资料 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"title":"剑指offer37 序列化二叉树","text":"题目描述请实现两个函数，分别用来序列化和反序列化二叉树。 示例: 123456789你可以将以下二叉树： 1 / \\ 2 3 / \\ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 解题思路方法一：序列化资料 https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"剑指offer32-Ⅰ 从上到下打印二叉树","text":"题目描述从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回： 1[3,9,20,15,7] 提示： 节点总数 &lt;= 1000 解题思路方法一：广度优先搜索、队列 12345678910111213141516171819202122232425public static class Solution32_1 { public int[] levelOrder(TreeNode root) { if (root == null) { return new int[0]; } List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } int[] res = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++) { res[i] = list.get(i); } return res; }} 方法二：递归 资料 https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer32-%E2%85%A0-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"剑指offer31 栈的压入、弹出序列","text":"题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 解题思路方法一：模拟 方法二：栈 代码实现12345678910111213141516171819202122232425262728class Solution31 { // 使用栈进行模拟 public boolean validateStackSequences(int[] pushed, int[] popped) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int index = 0; for (int i = 0; i &lt; pushed.length; i++) { stack.push(pushed[i]); while (!stack.isEmpty() &amp;&amp; stack.peek() == popped[index]) { stack.pop(); index++; } } return stack.isEmpty(); } // 直接把pushed数值作为栈使用。 public boolean validateStackSequences1(int[] pushed, int[] popped) { int top = -1, index = 0; for (int i = 0; i &lt; pushed.length; i++) { pushed[++top] = pushed[i]; while (top != -1 &amp;&amp; pushed[top] == popped[index]) { top--; index++; } } return top == -1; }} 资料 https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"},{"title":"剑指offer39 数组中出现次数超过一半的数字","text":"题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 12输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2 限制： 11 &lt;= 数组长度 &lt;= 50000 解题思路方法一：排序 方法二：投票法 代码实现1234567891011121314151617181920212223class Solution39 { // 排序 数组一定存在，则中间的数就是超过一半的数 public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length / 2]; } // 投票法 public int majorityElement2(int[] nums) { int ans = 0, vote = 0; for (int num : nums) { if (vote == 0) { ans = num; } if (ans == num) { vote++; } else { vote--; } } return ans; }} 资料https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指offer38 字符串的排列","text":"题目描述输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例: 12输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] 解题思路方法一：回溯法资料 https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"},{"title":"剑指offer41 数据流中的中位数","text":"题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1： 1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000] 示例 2： 1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000] 限制： 最多会对 addNum、findMedian 进行 50000 次调用。 解题思路方法一：堆 （最大堆+最小堆）资料 https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"剑指offer42 连续子数组的最大和","text":"题目描述输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5 -100 &lt;= arr[i] &lt;= 100 解题思路方法一：动态规划代码实现123456789101112131415static class Solution42 { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for (int num : nums) { if (sum &gt; 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }} 复杂度分析 时间复杂度： 空间复杂度： 资料https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/","link":"/2021/06/08/%E5%89%91%E6%8C%87offer42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"title":"剑指offer44 数字序列中某一位的数字","text":"题目描述数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例 1： 12输入：n = 3输出：3 示例 2： 12输入：n = 11输出：0 限制： 0 &lt;= n &lt; 2^31 解题思路方法一：数学代码实现资料 https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指offer40 最小的k个数","text":"题目描述输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 12输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1] 示例 2： 12输入：arr = [0,1,2,1], k = 1输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 解题思路方法一：排序方法二：最小堆方法三：快排代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Solution40 { // 排序 直接复制最小的K个数 public int[] getLeastNumbers(int[] arr, int k) { if (k &lt;= 0 || arr.length == 0) { return new int[0]; } int[] ans = new int[k]; Arrays.sort(arr); // System.arraycopy(arr, 0, ans, 0, k); for (int i = 0; i &lt; k; i++) { ans[i] = arr[i]; } return ans; } // 堆排序 public int[] getLeastNumbers2(int[] arr, int k) { if (k &lt;= 0 || arr.length == 0) { return new int[0]; } // 最小堆 TODO 确认compare的作用 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); // 堆的大小为K for (int i = 0; i &lt; k; i++) { queue.offer(arr[i]); } for (int i = k; i &lt; arr.length; i++) { if (arr[i] &lt; queue.peek()) { queue.poll(); queue.offer(arr[i]); } } int[] ans = new int[k]; for (int i = 0; i &lt; k; i++) { ans[i] = queue.poll(); } return ans; } // 快排思想 public int[] getLeastNumbers3(int[] arr, int k) { if (k &lt;= 0 || arr.length == 0 || k &gt; arr.length) { return new int[0]; } quickSort(arr, 0, arr.length - 1, k - 1); int[] ans = new int[k]; // System.arraycopy(arr, 0, ans, 0, k); for (int i = 0; i &lt; k; i++) { ans[i] = arr[i]; } return ans; } private void quickSort(int[] arr, int left, int right, int k) { if (left &gt;= right) { return; } int index = quick(arr, left, right); System.out.println(index); if (k == index) { return; } else if (index &lt; k) { quickSort(arr, index + 1, right, k); } else { quickSort(arr, left, index - 1, k); } } private int quick(int[] arr, int left, int right) { int key = arr[left]; int indexLeft = left; while (left &lt; right) { while (left &lt; right &amp;&amp; arr[right] &gt;= key) { right--; } while (left &lt; right &amp;&amp; arr[left] &lt;= key) { left++; } if (left &lt; right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } } arr[indexLeft] = arr[left]; arr[left] = key; return left; }} 资料 https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"},{"title":"剑指offer43 1到n整数中1出现的次数","text":"题目描述输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1： 12输入：n = 12输出：5 示例 2： 12输入：n = 13输出：6 限制： 1 &lt;= n &lt; 2^31 解题思路方法一：数学统计 代码实现1 资料https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer43-1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"},{"title":"剑指 Offer45 把数组排成最小的数【排序】","text":"题目描述输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1: 12输入: [10,2]输出: &quot;102&quot; 示例 2: 12输入: [3,30,34,5,9]输出: &quot;3033459&quot; 提示: 0 &lt; nums.length &lt;= 100 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 解题思路方法一：排序 将numbers数组先转换为String数组，进而对转换后的String 数组进行排序，排序的比较函数为 字符串小的排序在前即（x,y）-&gt;(x+y).compareTo(y+x)，最终将排序后的String数组依次合并形成最终答案。 实现代码123456789101112131415161718import java.util.ArrayList;import java.util.Arrays;public class Solution { public String PrintMinNumber(int [] numbers) { int len = numbers.length; String[] strs = new String[len]; for (int i = 0; i &lt; len; i++) { strs[i] = String.valueOf(numbers[i]); } Arrays.sort(strs, (x, y) -&gt; (x + y).compareTo(y + x)); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; len; i++) { stringBuilder.append(strs[i]); } return stringBuilder.toString(); }} 复杂度分析 时间复杂度：O(log n), [排序O(log n)；其他O(n)] 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/","link":"/2021/05/27/%E5%89%91%E6%8C%87offer45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"},{"title":"剑指offer46 把数字翻译成字符串【DP】","text":"题目描述给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 提示： 0 &lt;= num &lt; 231 解题思路方法一：动态规划 先将数字转化为字符串进行，进而判断连续的两个字符组成的两位字符串是否在10~25的范围内，分为两种情况进行动态规划。 动态规划的转移方程为： 分为两种情况： 第一种：第i位和第i-1位字符组成字符串在 10~25范围内，则 $$dp[i]=dp[i-1]+dp[i-2]$$ 第二种：第i位和第i-1位字符组成字符串不在 10~25范围内，则 $$dp[i]=dp[i-1]$$ 此题可对数组优化为两个变量进行。 代码实现12345678910111213141516class Solution { public int translateNum(int num) { String s = String.valueOf(num); int a = 1, b = 1; for (int i = 1; i &lt; s.length(); i++) { String temp = s.substring(i - 1, i+1); int c = a; if (temp.compareTo(&quot;10&quot;) &gt;= 0 &amp;&amp; temp.compareTo(&quot;25&quot;) &lt;= 0) { c = a + b; } b = a; a = c; } return a; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源 https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"剑指offer50 第一个只出现一次的字符【哈希表、查找】","text":"题目描述在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例: 12345s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot; 限制： 10 &lt;= s 的长度 &lt;= 50000 解题思路方法一：哈希表 两边遍历字符串，第一遍统计每个字符出现的次数，第二遍从头开始遍历，判断字符是否出现一次，如果出现次数为1,则返回答案，如果遍历结束后，没有找到答案，则返回’ ‘; 代码实现12345678910111213141516class Solution { public char firstUniqChar(String s) { int []nums=new int [95]; for(int i=0;i&lt;s.length();i++){ int index=s.charAt(i)-32; nums[index]++; } for(int i=0;i&lt;s.length();i++){ int index=s.charAt(i)-32; if(nums[index]==1){ return s.charAt(i); } } return ' '; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 方法二：查找 由于本题字符串只包含小写字母，可以两次查找字符串，分别找出单个字符出现的第一个位置和最后一个位置，时间复杂度为O(n). 如果找到的位置都为同一个位置，则该字符子出现一次，记录该下标； 如果出现多个只出现一个字符，则保留最小下标的只出现一个字符的下标。 如果没有出现，则返回’ ‘; 代码实现1234567891011121314151617181920class Solution { public char firstUniqChar(String s) { if(s==null || s.length() == 0) return ' '; int firstIndex = s.length(); for(char a = 'a'; a &lt;= 'z'; a++){ int i = s.indexOf(a); if(i &gt;=0 &amp;&amp; i == s.lastIndexOf(a)){ if(firstIndex &gt; i){ firstIndex = i; } } } return firstIndex == s.length() ? ' ' : s.charAt(firstIndex); }}// s.indexOf(a); [从前往后遍历] 找到第一个出现字符就返回下标，找不到就返回-1;// s.lastIndexOf(a);[从后往前遍历] 找到最后一个出现字符就返回下标，找不到就返回-1; 复杂度分析 时间复杂度：O(n) O(26n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"title":"剑指offer48 最长不重复字符的子字符串【哈希表、双指针】","text":"题目描述请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 提示： s.length &lt;= 40000 解题思路方法一：双指针+哈希表（Map）​ 利用双指针加哈希表的方法，哈希表记录最近一次字符的下标，一轮遍历字符串，当发现字符已经出现过，则 计算从left到当前的字符串长度； 设置left指针至（前一个出现的位置 和 left原先指向的位置）的最大值。 代码实现123456789101112131415161718192021class Solution { public int lengthOfLongestSubstring(String s) { if(s==null||s.length()==0){ return 0; } int len = s.length(); int ans = 0; int left = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; len; i++) { char c = s.charAt(i); if (map.containsKey(c)) { ans = Math.max(ans, i - left); left = Math.max(map.get(c) + 1, left); } map.put(c,i); } ans = Math.max(ans, len - left); return ans; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1), 字符的 ASCII 码范围为 0 ~ 127，所以map最多存放128个键值对，O(128). 方法二：双指针+哈希表（数组） 字符的 ASCII 码范围为 0 ~ 127,所以直接申请128空间的int数组来记录字符的下标 代码实现12345678910111213141516171819202122class Solution { public int lengthOfLongestSubstring(String s) { if (s == null || s.length() == 0) { return 0; } int len = s.length(); int ans = 0; int left = 0; int[] last = new int[128]; int f = s.charAt(0); for (int i = 1; i &lt; len; i++) { int c = s.charAt(i); if (last[c] != 0 || c == f) { ans = Math.max(ans, i - left); left = Math.max(last[c] + 1, left); } last[c] = i; } ans = Math.max(ans, len - left); return ans; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资源 https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/ https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer48-%E6%9C%80%E9%95%BF%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"剑指offer47 礼物的最大价值【DP】","text":"题目描述在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 示例 1: 12345678输入: [ [1,3,1], [1,5,1], [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 提示： 0 &lt; grid.length &lt;= 200 0 &lt; grid[0].length &lt;= 200 解题思路方法一：动态规划 利用动态规划的思想，使得到达每个点的价值都为最大值。 状态转移方程： 选择来自 上方 或者 左边 最大价值的。$$dp[i][j]=dp[i][j]+Math.max(dp[i-1][j],dp[i][j-1])$$ 代码实现123456789101112131415161718192021class Solution { public int maxValue(int[][] grid) { if (grid==null||grid.length == 0 || grid[0].length == 0) { return -1; } int rows = grid.length; int columns = grid[0].length; for (int i = 1; i &lt; columns; i++) { grid[0][i] += grid[0][i - 1]; } for (int i = 1; i &lt; rows; i++) { grid[i][0] += grid[i - 1][0]; } for (int i = 1; i &lt; rows; i++) { for (int j = 1; j &lt; columns; j++) { grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]); } } return grid[rows - 1][columns - 1]; }} 复杂度分析 时间复杂度：O($n^2$) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"title":"剑指offer49 丑数【双指针】","text":"题目描述我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 示例: 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路 利用三个指针的方法，分别指向2，3，5的系数的位置，系数都为1开始，如果当前的数为系数于2，3，5的乘积，则系数右移一个数。 实现代码1234567891011121314151617181920212223242526272829class Solution { public int nthUglyNumber(int n) { if(n&lt;=0){ return 0; } int[] dp=new int[n]; dp[0]=1; int a=0; int b=0; int c=0; for(int i=1;i&lt;n;i++){ int num2=dp[a]*2; int num3=dp[b]*3; int num5=dp[c]*5; int num=Math.min(num2,Math.min(num3,num5)); dp[i]=num; if(num==num2){ a++; } if(num==num3){ b++; } if(num==num5){ c++; } } return dp[n-1]; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/chou-shu-lcof/","link":"/2021/05/28/%E5%89%91%E6%8C%87offer49-%E4%B8%91%E6%95%B0/"},{"title":"剑指offer51 数组中的逆序对【分治、归并】","text":"剑指 Offer 51. 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例 1: 12输入: [7,5,6,4]输出: 5 限制： 10 &lt;= 数组长度 &lt;= 50000 解题思路方法一：归并排序 利用分治算法思想，归并排序，在归并的过程中计算逆序对的大小； 具体思路讲解可前往leetcode网站上观看视频讲解，了解已在资料中给出。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int reversePairs(int[] nums) { if (nums == null || nums.length &lt;= 1) { return 0; } int temp[] = new int[nums.length]; return mergeSort(nums, 0, nums.length - 1, temp); } private int mergeSort(int[] nums, int left, int right, int[] temp) { if (left == right) { return 0; } int mid = left + (right - left) / 2; int leftPairs = mergeSort(nums, left, mid, temp); int rightPairs = mergeSort(nums, mid + 1, right, temp); if (nums[mid] &lt;= nums[mid + 1]) { return leftPairs + rightPairs; } int mergePairs = merge(nums, left, mid, right, temp); return leftPairs + rightPairs + mergePairs; } private int merge(int[] nums, int left, int mid, int right, int[] temp) { int i = left, j = mid + 1; int count = 0; for (int k = left; k &lt;= right; k++) { if (i == mid + 1) { temp[k] = nums[j++]; } else if (j == right + 1) { temp[k] = nums[i++]; } else if (nums[i] &lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; count += mid - i + 1; } } for (int k = left; k &lt;= right; k++) { nums[k] = temp[k]; } return count; }} 复杂度分析 时间复杂度：O(n log n ) 空间复杂度：O(1) 方法二：暴力法 两重循环遍历判断是否存在逆序对 代码实现123456789101112131415public class Solution { public int reversePairs(int[] nums) { int count = 0; int len = nums.length; for (int i = 0; i &lt; len - 1; i++) { for (int j = i + 1; j &lt; len; j++) { if (nums[i] &gt; nums[j]) { count++; } } } return count; }} 复杂度分析 时间复杂度：O($n^2$ ) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/ 视频讲解：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/","link":"/2021/05/29/%E5%89%91%E6%8C%87offer51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"title":"剑指offer52 两个链表的第一个公共节点【双指针】","text":"题目描述输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路方法一：模拟+双指针 先计算出两个链表的长度，让长的一方先走 两方的距离差，进而像快慢指针一样一起往前走，判断是否相等 代码实现123456789101112131415161718192021222324252627282930313233343536373839public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int sizeA = 0, sizeB = 0; ListNode nodeA = headA; while (nodeA != null) { sizeA++; nodeA = nodeA.next; } ListNode nodeB = headB; while (nodeB != null) { sizeB++; nodeB = nodeB.next; } if (sizeA == 0 || sizeB == 0) { return null; } nodeA = headA; nodeB = headB; if (sizeA &gt; sizeB) { int len = sizeA - sizeB; while (len &gt; 0) { len -= 1; nodeA = nodeA.next; } } else if (sizeB &gt; sizeA) { int len = sizeB - sizeA; while (len &gt; 0) { len -= 1; nodeB = nodeB.next; } } while (nodeA != null &amp;&amp; nodeB != null) { if (nodeA == nodeB) { return nodeA; } nodeA = nodeA.next; nodeB = nodeB.next; } return null;} 复杂度分析 时间复杂度：O(a+b) 空间复杂度：O(1) 方法二：模拟+双指针 两方在各自的链表上顺序遍历一步，遍历完自己后遍历对方的，直到找到共同节点或者为null。当走到对方上，走的步数是相同的（a+b)-c;c为共同结点的个数。 代码实现12345678910public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode A = headA, B = headB; while (A != B) { A = A != null ? A.next : headB; B = B != null ? B.next : headA; } return A; }} 复杂度分析 时间复杂度：O(a+b) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/ https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/jian-zhi-offer-52-liang-ge-lian-biao-de-gcruu/","link":"/2021/05/29/%E5%89%91%E6%8C%87offer52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"title":"剑指offer53-Ⅰ 在排序数组中查找数字Ⅰ【二分查找】","text":"剑指 Offer 53 - I. 在排序数组中查找数字 I题目描述统计一个数字在排序数组中出现的次数。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: 2 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: 0 限制： 10 &lt;= 数组长度 &lt;= 50000 解题思路方法一：二分查找 先二分查找到target后，在对查找到的数字前后搜索，统计完所有target值的数量 实现代码123456789101112131415161718192021222324252627class Solution { public int search(int[] nums, int target) { int right = nums.length - 1, left = 0; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { int res = 1; int temp = mid - 1; mid++; while (mid &lt; nums.length &amp;&amp; nums[mid] == target) { res++; mid++; } while (temp &gt;= 0 &amp;&amp; nums[temp] == target) { res++; temp--; } return res; } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return 0; }} 复杂度分析 时间复杂度：O(log n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/","link":"/2021/05/30/%E5%89%91%E6%8C%87offer53-%E2%85%A0-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97%E2%85%A0/"},{"title":"剑指offer53-Ⅱ 0到n-1中缺失的数字【二分查找、数学】","text":"剑指 Offer 53 - II. 0～n-1中缺失的数字题目描述一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 12输入: [0,1,3]输出: 2 示例 2: 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 限制： 11 &lt;= 数组长度 &lt;= 10000 解题思路方法一：二分查找 仅适用于数组有序。 在数组有序的情况下，可进行二分查找，当nums[i]==i时，表示前i位都是在正确的位置上，没有缺失,则left=mid+1; 而当nums[i]!=i时，意味着缺失的数字发生在i位置及前面，则让right=mid-1; 返回值为 left. 代码实现12345678910111213// 数组有序的情况下public int missingNumber(int[] nums) { int left = 0, right = nums.length; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == mid) { left = mid + 1; } else { right = mid - 1; } } return left;} 复杂度分析 时间复杂度：O(log n) 空间复杂度：O(1) 方法二：数学 可适用于数组有序以及乱序 计算数组的和，用1-n之和减去数组的和，即为缺失的数字。 代码实现123456789public int missingNumber1(int[] nums) { int len = nums.length; int sum = 0; for (int num : nums) { sum += num; } return (len+1)*len/2-sum;}// 可能存在的问题，int溢出。 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/","link":"/2021/05/31/%E5%89%91%E6%8C%87offer53-%E2%85%A1-0%E5%88%B0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指offer54 二叉搜索树的第k大节点【DFS】","text":"题目描述给定一棵二叉搜索树，请找出其中第k大的节点。 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 4 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 4 限制： 1 ≤ k ≤ 二叉搜索树元素个数 解题思路方法一:深度优先搜索DFS 类似中序遍历思想，先遍历右子树后遍历左子树的，访问根节点时，对k进行减一操作，当k==0时，退出递归，设置res. 实现代码1234567891011121314151617181920212223242526class Solution54 { int res = -1, n; public int kthLargest(TreeNode root, int k) { if (root == null || k == 0) { return -1; } n = k; dfs(root); return res; } private void dfs(TreeNode root) { if (root == null) return; dfs(root.right); if (n == 0) { return; } if (--n == 0) { res = root.val; return; } dfs(root.left); }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) // 递归栈空间 资料 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/","link":"/2021/05/31/%E5%89%91%E6%8C%87offer54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"},{"title":"剑指offer55-Ⅰ 二叉树的深度【DFS】","text":"题目描述输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 提示： 节点总数 &lt;= 10000 解题思路方法一：深度优先搜索 dfs方法，后序遍历，计算出左右子树的长度，递归。 代码实现1234567891011121314151617181920212223public int maxDepth(TreeNode root) { if(root==null){ return 0; } return dfs(root);}private int dfs(TreeNode root) { if(root==null){ return 0; } int leftLevel=dfs(root.left); int rightLevel=dfs(root.right); return Math.max(leftLevel,rightLevel)+1;}public int maxDepth(TreeNode root) { if(root==null){ return 0; } return Math.max(maxDepth(root.left),maxDepth(root.right))+1;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 递归栈 方法二：层次遍历 层次遍历，计算有多少层。 代码实现12345678910111213141516171819202122public int maxDepth(TreeNode root) { if (root == null) { return 0; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int res = 0; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } res++; } return res;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/","link":"/2021/05/31/%E5%89%91%E6%8C%87offer55-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"},{"title":"剑指offer55-Ⅱ 平衡二叉树【DFS】","text":"题目描述输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \\9 20 / \\ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1234567 1 / \\ 2 2 / \\ 3 3 / \\4 4 返回 false 。 限制： 0 &lt;= 树的结点个数 &lt;= 10000 解题思路方法一：深度优先搜索 dfs方法，后序遍历，计算出左右子树的长度，判断左右子树的高度差的绝对值是否小于1，即判断是否为平衡二叉树，递归。 代码实现12345678910111213141516// -1为不平衡状态，平衡状态下返回树的高度public boolean isBalanced(TreeNode root) { return maxDepth(root) != -1;}private int maxDepth(TreeNode root) { if (root == null) return 0; int left = maxDepth(root.left); if(left == -1) return -1; int right = maxDepth(root.right); if(right == -1) return -1; return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 递归栈 资料 https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/","link":"/2021/05/31/%E5%89%91%E6%8C%87offer55-%E2%85%A1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"剑指offer56-Ⅱ 数组中出现的次数Ⅱ【数学】","text":"剑指 Offer 56 - II. 数组中数字出现的次数 II题目描述在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 示例 1： 12输入：nums = [3,4,3,3]输出：4 示例 2： 12输入：nums = [9,1,7,9,7,9,7]输出：1 限制： 1 &lt;= nums.length &lt;= 10000 1 &lt;= nums[i] &lt; 2^31 解题思路方法一：数学-状态机 数学方法 00-&gt;01-&gt;10-&gt;00; 代码实现1234567891011class Solution { public int singleNumber(int[] nums) { // two one int ones = 0, twos = 0; for(int num : nums){ ones = ones ^ num &amp; ~twos; twos = twos ^ num &amp; ~ones; } return ones; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/","link":"/2021/06/03/%E5%89%91%E6%8C%87offer56-%E2%85%A1-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E2%85%A1/"},{"title":"剑指offer57-Ⅱ 和为s的连续正数序列【双指针】","text":"题目描述输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 12输入：target = 9输出：[[2,3,4],[4,5]] 示例 2： 12输入：target = 15输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： 1 &lt;= target &lt;= 10^5 解题思路方法一：双指针 左右指针，进行计算从左指针到右指针之和，如果小于target，则right指针右移，如果大于target则left右移。如果等于target,则将left到right的数字进行保存。 代码实现123456789101112131415161718192021class Solution57_2 { public int[][] findContinuousSequence(int target) { List&lt;int[]&gt; vec = new ArrayList&lt;&gt;(); for (int l = 1, r = 2; l &lt; r;) { int sum = (l + r) * (r - l + 1) / 2; if (sum == target) { int[] res = new int[r - l + 1]; for (int i = l; i &lt;= r; ++i) { res[i - l] = i; } vec.add(res); l++; } else if (sum &lt; target) { r++; } else { l++; } } return vec.toArray(new int[vec.size()][]); }} 复杂度分析： 时间复杂度：O(target) 空间复杂度：O(1) #除答案需要的空间外 资料 https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/","link":"/2021/06/05/%E5%89%91%E6%8C%87offer57-%E2%85%A1-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"},{"title":"剑指offer56-Ⅰ 数组中数字出现的次数【数学】","text":"题目描述一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是**O(n)，空间复杂度是O(1)**。 示例 1： 12输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1] 示例 2： 12输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums.length &lt;= 10000 解题思路方法一：数学-异或 先遍历一遍数组，用0异或所有数，得出结果为t,则t为答案值a,b的异或结果，则将cp=1，进行处理，得到a,b两个数不同的最小位。 再一次遍历数组，如果数与cp的和&amp;值为0，则被分为a，不为0,被分为b. 则结果a为a类所有数的异或值。 代码实现12345678910111213141516171819202122class Solution { public int[] singleNumbers(int[] nums) { int len = nums.length; if (len == 0) { return new int[0]; } int a = 0, b = 0, t = 0; for (int i = 0; i &lt; len; i++) { t = t ^ nums[i]; } int cp = 1; while ((cp &amp; t) == 0) { cp = cp &lt;&lt; 1; } for (int i = 0; i &lt; len; i++) { if ((cp &amp; nums[i]) == 0) { a = a ^ nums[i]; } } return new int[]{a, a^t};//求出a后，则b=a^t t为a^b. }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/","link":"/2021/06/03/%E5%89%91%E6%8C%87offer56-%E2%85%A0-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"},{"title":"剑指offer58-Ⅰ 翻转单词顺序【字符串】","text":"题目描述输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 示例 1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解题思路方法一：遍历 先去掉字符串首尾的空格，从后往前遍历得到（无空格）字符串后加入到StringBuilder中。 代码实现12345678910111213141516171819class Solution58_1 { public String reverseWords(String s) { s = s.trim(); int j = s.length() - 1; int i = j; StringBuilder stringBuilder = new StringBuilder(); while (i &gt;= 0) { while (i &gt;= 0 &amp;&amp; s.charAt(i) != ' ') { i--; } stringBuilder.append(s, i + 1, j + 1).append(' '); while (i &gt;= 0 &amp;&amp; s.charAt(i) == ' ') { i--; } j = i; } return stringBuilder.toString().trim(); }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 方法二：split函数分割 使用split函数将字符串分割成字符串数组。 代码实现123456789101112131415161718public String reverseWords(String s) { //将传进来的字符串以空格拆分 String[] strings = s.trim().split(&quot; &quot;); StringBuffer stringBuffer = new StringBuffer(); //从尾巴开始遍历 for (int i = strings.length - 1; i &gt;= 0; i--) { // 两个空格间会被分割成&quot;&quot; if (strings[i].equals(&quot;&quot;)) { continue; } if (i == 0) { stringBuffer.append(strings[i]); } else { stringBuffer.append(strings[i]).append(&quot; &quot;); } } return stringBuffer.toString();} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/ 《剑指offer》","link":"/2021/06/05/%E5%89%91%E6%8C%87offer58-%E2%85%A0-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"},{"title":"剑指offer58-Ⅱ 左旋转字符串【字符串】","text":"题目描述字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例 1： 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 示例 2： 12输入: s = &quot;lrloseumgh&quot;, k = 6输出: &quot;umghlrlose&quot; 限制： 1 &lt;= k &lt; s.length &lt;= 10000 解题思路方法一:字符串 len长度字符串，先将n~len加入到StringBuilder，后将0到n加入到StringBuilder中。 代码实现12345678910111213141516171819public String reverseLeftWords(String s, int n) { StringBuilder stringBuilder = new StringBuilder(); int len = s.length(); n = n % len; if (n == 0) { return s; } for (int i = n; i &lt; len; i++) { stringBuilder.append(s.charAt(i)); } for (int i = 0; i &lt; n; i++) { stringBuilder.append(s.charAt(i)); } // 取余操作 //for (int i = n; i &lt; n+len; i++) { // stringBuilder.append(s.charAt(i%len)); //} return stringBuilder.toString();} 复杂度分析 时间复杂度:O(n) 空间复杂度:O(n) 方法二：substring() 使用String内置substring函数 代码实现123456public String reverseLeftWords(String s, int n) { int a = s.length(); String str = s.substring(0, n); String str2 = s.substring(n, a); return str2 + str;} 复杂度分析 时间复杂度:O(n) 空间复杂度:O(1) 资料 https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/","link":"/2021/06/05/%E5%89%91%E6%8C%87offer58-%E2%85%A1-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"剑指offer57 和为s的两个数字【双指针】","text":"题目描述输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例 1： 12输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2] 示例 2： 12输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10] 限制： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6 解题思路方法一：双指针 从头尾两指针向中间遍历。 代码实现123456789101112131415class Solution { public int[] twoSum(int[] nums, int target) { int left=0,right=nums.length-1; while(left&lt;right){ if(nums[left]+nums[right]&lt;target){ left++; }else if(nums[left]+nums[right]&gt;target){ right--; }else{ return new int[]{nums[left],nums[right]}; } } return new int[2]; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/","link":"/2021/06/03/%E5%89%91%E6%8C%87offer57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"title":"剑指offer59-Ⅱ 队列的最大值【设计、队列】","text":"题目描述请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1 示例 1： 1234输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2] 示例 2： 1234输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1] 限制： 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000 1 &lt;= value &lt;= 10^5 解题思路方法一：队列 使用双端队列来保存最大值，如果加入的值比双端队列的尾部大，则将尾部元素退出，尾部元素大于等于即将加入的值或者双端队列为空。 代码实现12345678910111213141516171819202122232425262728293031323334353637class MaxQueue { Queue&lt;Integer&gt; q; Deque&lt;Integer&gt; d; public MaxQueue() { q = new LinkedList&lt;Integer&gt;(); d = new LinkedList&lt;Integer&gt;(); } public int max_value() { if (d.isEmpty()) { return -1; } return d.peekFirst(); } public void push_back(int value) { // 将加入的值加入到双端队列中 while (!d.isEmpty() &amp;&amp; d.peekLast() &lt; value) { d.pollLast(); } d.offerLast(value); q.offer(value); } public int pop_front() { if (q.isEmpty()) { return -1; } int ans = q.poll(); if (ans == d.peekFirst()) { d.pollFirst(); } return ans; }} 复杂度分析 max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/","link":"/2021/06/05/%E5%89%91%E6%8C%87offer59-%E2%85%A1-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"剑指offer59-Ⅰ 滑动窗口的最大值","text":"","link":"/2021/06/05/%E5%89%91%E6%8C%87offer59-%E2%85%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"title":"剑指offer62 圆圈中最后剩下的数字【约瑟夫问题】","text":"题目描述0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 12输入: n = 5, m = 3输出: 3 示例 2： 12输入: n = 10, m = 17输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 解题思路[约瑟夫问题]方法一：数学+递归递归方程$$f(n,m)=f(n-1,m)+m) % n$$ 代码实现123456789101112public int lastRemaining(int n, int m) { return f(n, m);}private int f(int n, int m) { if (n == 1) { return 0; } int x = f(n - 1, m); System.out.println(x); return (m + x) % n;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) #递归栈 方法二：数学+迭代 使用的迭代的方法优化递归。 代码实现1234567public int lastRemaining2(int n, int m) { int f = 0; for (int i = 2; i &lt;= n; ++i) { f = (m + f) % i; } return f;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 问题本题是找出最后剩下的那个数，如何找到第n个淘汰的数呢？如何得出每一轮淘汰的数呢？ 资料 https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/ https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-by-lee/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/"},{"title":"剑指offer61 扑克牌中的顺子【数学、辅助数组】","text":"题目描述从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例1: 12输入: [1,2,3,4,5]输出: True 示例 2: 12输入: [0,0,1,2,5]输出: True 限制： 数组长度为 5 数组的数取值为 [0, 13] . 解题思路方法一：辅助数组 使用一个辅助数组来做标记，标记是否已经出现该牌，如果num为0,则跳过，如果出现过则返回false,然后比较得出最大值，最小值。最后比较最大值和最小值的差是否小于等于4即可。 代码实现123456789101112131415161718class Solution61 { public boolean isStraight(int[] nums) { boolean[] flag = new boolean[14]; int min = 13, max = 0; for (int num : nums) { if (num == 0) { continue; } if (flag[num]) { return false; } max = Math.max(max, num); min = Math.min(min, num); flag[num] = true; } return max - min &lt;= 4; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/","link":"/2021/06/05/%E5%89%91%E6%8C%87offer61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"title":"剑指offer63 股票的最大利润【DP】","text":"题目描述假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 限制： 0 $\\leq$ 数组长度 $\\leq10^5$ 解题思路方法一：一次遍历 使用minprice变量当前数组自己之前可购买的最小价格。 maxprofit表示截止目前位置最大收益。 代码实现1234567891011121314public class Solution { public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minprice) { minprice = prices[i]; } else if (prices[i] - minprice &gt; maxprofit) { maxprofit = prices[i] - minprice; } } return maxprofit; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"title":"剑指offer66 构建乘积数组【辅助数组】","text":"题目描述给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 示例: 12输入: [1,2,3,4,5]输出: [120,60,40,30,24] 提示： 所有元素乘积之和不会溢出 32 位整数 a.length &lt;= 100000 解题思路方法一：辅助数组 由于题目给出不能使用除法操作，那么可以直接先计算出左边的乘积数组和右边的乘积数组。最后将两个数组相乘得出最终结果。 代码实现123456789101112131415161718192021public int[] constructArr(int[] a) { int len = a.length; if (len == 0) { return new int[0]; } int[] left = new int[len]; int[] right = new int[len]; int[] res = new int[len]; left[0] = 1; right[len - 1] = 1; for (int i = 1; i &lt; len; i++) { left[i] = left[i - 1] * a[i - 1]; } for (int i = len - 2; i &gt;= 0; i--) { right[i] = right[i + 1] * a[i + 1]; } for (int i = 0; i &lt; len; i++) { res[i] = left[i] * right[i]; } return res;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 优化代码实现 优化空间，将left,right数组用一个变量来替代，节省空间开销 1234567891011121314151617181920public int[] constructArr(int[] a) { int len = a.length; if (len == 0) { return new int[0]; } int[] res = new int[len]; int temp = 1; // 先将left乘积存入res数组中 for (int i = 0; i &lt; len; i++) { res[i] = temp; temp = temp * a[i]; } // 再将right数组乘以res数组。 temp = 1; for (int i = len - 1; i &gt;= 0; i--) { res[i] = res[i] * temp; temp = temp * a[i]; } return res;} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) // 除答案使用空间 资料 https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"},{"title":"剑指offer60 n个骰子的点数【DP】","text":"题目描述把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1: 12输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2: 12输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 限制： 11 &lt;= n &lt;= 11 解题思路方法一：动态规划$$f(n,x)=\\sum^{6}_{1}f(n-1,x-i)✖\\frac{1}{6}$$ 代码实现12345678910111213141516class Solution60 { public double[] dicesProbability(int n) { double[] dp = new double[6]; Arrays.fill(dp, 1.0 / 6.0); for (int i = 2; i &lt;= n; i++) { double[] tmp = new double[5 * i + 1]; for (int j = 0; j &lt; dp.length; j++) { for (int k = 0; k &lt; 6; k++) { tmp[j + k] += dp[j] / 6.0; } } dp = tmp; } return dp; }} 复杂度分析 时间复杂度：O($n ^ 2$) 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/ https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/solution/jian-zhi-offer-60-n-ge-tou-zi-de-dian-sh-z36d/","link":"/2021/06/05/%E5%89%91%E6%8C%87offer60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/"},{"title":"剑指offer65 不用加减乘除做加法【位运算】","text":"题目描述写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例: 12输入: a = 1, b = 1输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路方法一：位运算 异或操作 0^1=1 1^0=1 0^0=0 1^1=0，那么先进行异或操作可以得出不考虑进位的情况&amp;与操作，可以得出哪一位发生进位，再将进位左移1位后，再与前面的异或操作的结果进行相加操作。直到无进位情况。 代码实现12345678910class Solution { public int add(int a, int b) { while (b != 0) { int c = (a &amp; b) &lt;&lt; 1; a = a ^ b; b = c; } return a; }} 复杂度分析 时间复杂度：O(1) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"},{"title":"剑指offer68-Ⅰ 二叉搜索树的最近公共祖先【二叉搜索树性质】","text":"题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路方法一：二叉搜索树性质 利用二叉搜索树的性质来进行本题解答，找出两个节点的最近公共祖先。二叉搜索树保证：左子树的所有结点的值小于根节点的值，右子树的所有结点值大于根节点的值。每个结点都满足这样的性质 那么我们可以从树的根节点来判断，如果两个结点的值都小于根节点的值，则这两个结点都在根结点的左子树中，那么继续遍历跟的左子树。 同理，如果两个结点的值都大于根节点的值，那么继续遍历跟的右子树。 如果出现其他情况，则可能为根节点就为其中两个结点的一个结点，或者两个结点的值分别大于、小于根节点的值，则根节点为最近公共祖先 代码实现123456789101112131415class Solution68_1 { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { TreeNode ancestor = root; while (true) { if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) { ancestor = ancestor.left; } else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) { ancestor = ancestor.right; } else { break; } } return ancestor; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer68-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"剑指offer64 求1+2+3+...+n 【递归】","text":"题目描述求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 12输入: n = 3输出: 6 示例 2： 12输入: n = 9输出: 45 限制： 1 &lt;= n &lt;= 10000 解题思路方法一：递归 使用递归方法，利用&amp;&amp;逻辑运算符来坐终止条件，例如A&amp;&amp;B，当A为true时，才进行B操作，如果A为false则不进行操作。 代码实现123456class Solution { public int sumNums(int n) { boolean flag = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0; return n; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/qiu-12n-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer64-%E6%B1%821-2-3-n/"},{"title":"剑指offer68-Ⅱ 二叉树的最近公共祖先【哈希表、递归+DFS】","text":"题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路方法一：递归+深度优先搜索 通过判断p、q结点是否为根节点的左右孩子。 如果分别为左右子树，则根节点为最近公共祖先。 如果根节点的值为p、q结点中的一个，且另一个为左右子树，那么当前根节点也为最近公共祖先 代码实现1234567891011121314151617class Solution { private TreeNode ans; private boolean dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return false; boolean lson = dfs(root.left, p, q); boolean rson = dfs(root.right, p, q); if ((lson &amp;&amp; rson) || ((root.val == p.val || root.val == q.val) &amp;&amp; (lson || rson))) { ans = root; } return lson || rson || (root.val == p.val || root.val == q.val); } public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { ans = null; this.dfs(root, p, q); return ans; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) #递归栈 方法二：哈希表 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。 代码实现123456789101112131415161718192021222324252627282930class Solution { Map&lt;Integer, TreeNode&gt; parent = new HashMap&lt;Integer, TreeNode&gt;(); Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;(); public void dfs(TreeNode root) { if (root.left != null) { parent.put(root.left.val, root); dfs(root.left); } if (root.right != null) { parent.put(root.right.val, root); dfs(root.right); } } public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { dfs(root); while (p != null) { visited.add(p.val); p = parent.get(p.val); } while (q != null) { if (visited.contains(q.val)) { return q; } q = parent.get(q.val); } return null; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 资料 https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-6fdt7/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer68-%E2%85%A1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"排序算法 归并排序","text":"归并排序12345678910111213141516171819202122232425262728293031323334353637383940private static void mergeSort(int[] nums, int left, int right, int[] temp) { if (left == right) { return; } int mid = left + (right - left) / 2; mergeSort(nums, left, mid, temp); mergeSort(nums, mid + 1, right, temp); merge(nums, left, mid, right, temp);}private static void merge(int[] nums, int left, int mid, int right, int[] temp) { int i = left, j = mid + 1; for (int k = left; k &lt;= right; k++) { if (i == mid + 1) { temp[k] = nums[j++]; } else if (j == right + 1) { temp[k] = nums[i++]; } else if (nums[i] &lt;= nums[j]) { temp[k] = nums[i++]; } else { temp[k] = nums[j++]; } } for (int k = left; k &lt;= right; k++) { nums[k] = temp[k]; }} public static void main(String[] args) { int[] num = {7,5,6,4,8,9,6,7,4,5,9,0,7,3}; System.out.println(&quot;未排序&quot;); System.out.println(Arrays.toString(num)); int[] temp = new int[num.length]; mergeSort(num, 0, num.length - 1, temp); System.out.println(&quot;排序后&quot;); System.out.println(Arrays.toString(num)); }","link":"/2021/05/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"调度","text":"调度调度的意义： The objective of scheduling is to allocate tasks onto the processors and then order their execution so that task dependence is satisfied and the length of the schedule, known as the parallel time, is minimized。 调度算法的可行解： Specifically, if the requests for all tasks at their critical instants are fulfilled before their respective deadlines, then the scheduling algorithm is feasible. 异构系统： Diverse sets of resources interconnected with a high-speed network provide a new computing platform, called the heterogeneous computing system, which can support executing computationally intensive parallel and distributed applications. 与高速网络互连的各种资源集提供了一个称为异构计算系统的新计算平台，该平台可以支持执行计算密集型并行和分布式应用程序。 任务调度模型： A scheduling system model consists of an application, a target computing environment, and a performance criteria for scheduling. 调度系统模型由应用程序、目标计算环境和调度性能标准组成。 任务调度的目标函数： The objective function of the task-scheduling problem is to determine the assignment of tasks of a given application to processors such that its schedule length is minimized. 1 Scheduling Algorithms for Multiprogramming in a Hard-Real-Time EnvironmentAuthor: C. L. LIU and JAMES W. LAYLAND JACM A类 1973年 题目： 硬实时环境中的多程序调度算法 优先级调度算法静态调度算法：调度的过程中，优先级不发生改变；即优先级只被赋值一次。 动态调度算法：调度的优先级过程中会发生改变，根据不同因素情况动态的修改任务的优先级。 混合调度算法：混合静态调度算法和动态算法，即所有任务中，一部分任务的优先级是不改变的，一部分任务的优先级会发生动态改变的。 论文中的调度算法1 A Fixed Priority Scheduling Algorithm 固定优先级调度算法，静态调度算法。rate-monotonic priority assignment 单调速率优先级分配算法​ 根据任务的请求周期时间T来进行对任务优先级赋值，当请求周期时间越小，则优先级越大；请求周期时间越大，则任务优先级越小。 ​ 调度算法分配优先级过程中没有考虑任务的运行时间。 ​ 所有能用静态优先级调度的任务集，都能使用RM算法来对该任务进行调度。 ​ RM调度算法是基于优先级静态调度算法中最优的调度算法。 2 The Deadline Driven Scheduling Algorithm 截止时间驱动调度算法，动态调度算法根据任务执行截止时间来进行对任务的动态赋值优先级； 当当前时间越接近截止时间时，任务的优先级越高；当当前时间离任务截止时间较远时，任务的优先级越低。 如果一组任务能用其他调度算法来调度的话，那么Deadline Driven Scheduling Algorithm算法也能进行调度。 Deadline Driven Scheduling Algorithm算法时最优的。 3 A Mixed Scheduling Algorithm 混合调度算法​ 所有任务中请求周期时间比较小的K个任务，采用固定优先级调度算法中rate-monotonic priority Algorithm,RM算法；其他任务采用动态调度算法中的The Deadline Driven Scheduling Algorithm算法。 ​ 优优结合。 2 DSC: Scheduling Parallel Tasks on an Unbounded Number of ProcessorsAuthor: Tao Yang, and Apostolos Gerasoulis 出处：TPDS:“PARALLEL AND DISTRIBUTED SYSTEMS.” A类 1994 categories: 聚类整合 DSC：在无数个处理器上调度并行任务 2.1 tlevel 定义：从起始结点entry node 到当前结点的最长路径。 Let $tlevel(n_i)$ be the length of the longest path from an entry (top) node to $n_x$, excluding the weight of $n_x$ in a DAG. 不包括自己的执行时间。 2.2 blevel 定义：从当前结点到exit node的最长时间。 let $blevel(n_x)$ be the length of the longest path from $n_x$, to an exit (bottom) node. 包括当前结点的执行时间。 2.3 PT 任务总的运行时间。 2.4 DSC-Ⅰ 算法 2.4 DSC-Ⅱ 算法 添加 partially free list 部分自由列表 3 HEFT:Performance-effective and low-complexity task scheduling for heterogeneous computingAuthor: H. Topcuoglu , S. Hariri , Min-You Wu 出处：TPDS:“PARALLEL AND DISTRIBUTED SYSTEMS.” A类 2002 categories: 列表法 用于异构计算的性能有效且低复杂度的任务调度,本文提出了两个算法，HEFT,CPOP； 有向无环图（DAG） 算法的核心步骤为两步： 第一步，如何制定任务结点（task）的优先级。 第二步，如何选取处理器的选择方式。 3.1 向上等级 upward rank 当前结点-&gt;退出结点（exit task）的需要时间。其中包含自己的平均执行时间。 $rank_{u}(n_{i}) = \\overline{w_{i}} + \\max_{n_{j} \\in succ(n_{i})} (\\overline{c_{i, j}} + rank_{u}(n_{j}))$ 3.2 向下等级 downward rank 起始结点（entry task）到当前结点的 最大时间(最快时间)（the longest distance).不包含当前结点的平均执行时间。 3.3 HEFT Algorithm ：The Heterogeneous-Earliest-Finish-Time Algorithm 任务选取阶段：任务的优先级为： $priority=rank_u$ 处理器选取阶段：基于插入策略选取处理，使得选取任务在最早时间完成（EFT）。 3.3.1 算法描述 1：初始化任务的计算成本（平均执行时间），任务间通信成本 2：从退出结点递归调用，得出每个任务（task）的向上等级值（$rank_u$） 3：将$rank_u$按非递增排序的调度队列。 4-9: 循环等待执行队列，直到等待队列为空： ​ 选取队列中第一个任务。 ​ 计算出该任务在每个处理器上的最早完成时间，选取出最早完成时间的最小值的处理器，将该任务分配给该处理器执行。 3.3.2 时间复杂度：$O(v^2 p)$3.4 CPOP Algorithm：The Critical-Path-on-a-Processor Algorithm 任务选取阶段：任务的优先级为： $priority=rank_u + rank_d$ 根据任务的优先级（|CP|=priority($n_{entry}$)）得出关键路径的结点，加入到关键结点队列 计算关键结点路径在每个处理器的执行时间总和，选择总和最小值的处理器固定为关键路径结点处理器。 处理器选取阶段：根据优先级排序顺序进行选取任务结点。 任务结点 在 关键路径队列 中： ​ 关键路径专属处理器； 不在： ​ EFT循环遍历所有处理器，选择最早时间完成的处理器。 3.4.1 算法描述 1：初始化任务的计算成本（平均执行时间），任务间通信成本 2：从退出结点递归调用，得出每个任务（task）的向上等级值（$rank_u$） 3：从开始结点向下调用，得出每个任务（task）的向下等级值（$rank_d$） 4：计算每个任务的优先级：$priority=rank_u+rank_d$ 5-12: 循环所有任务得出关键路径队列 $SET_{CP}$ 13：选取关键路径队列结点的最佳选择处理器。 14-21：根据规则进行选取任务和任务对应处理器进行工作。 规则： 根据优先级队列（堆）进行选取任务结点。 任务结点 在 关键路径队列 中： ​ 关键路径专属处理器； 不在： ​ EFT循环遍历所有处理器，选择最早时间完成的处理器。 更新优先级队列，加入执行任务的后继结点中的ready tasks(准备任务) 3.4.2 时间复杂度：$O(e \\cdot q )$ 4 PEFT: List Scheduling Algorithm for Heterogeneous Systems by an Optimistic Cost TableAuthor：Hamid Arabnejad and Jorge G. Barbosa 出处：TPDS:“PARALLEL AND DISTRIBUTED SYSTEMS.” A类 2014 categories: 列表法 4.1 Optimistic Cost Table 乐观成本表 主要用于考虑后继结点的预计最早完成时间。 计算出每个任务的$rank_{ock}$ 4.2 PEFT Algorithm ：Predict Earliest Finish Time Algorithm4.2.1 算法描述 Algorithm 1. The PEFT Algorithm.1: Compute OCT table and $rank_{oct}$for all tasks2: Create Empty list ready-list and put $n_{entry}$ as initial task3: while ready-list is NOT Empty do4: $n_i\\leftarrow$ the task with highest $rank_{oct}$ from ready-list5: for all processor $p_j$ in the processor-set P do6: Compute $EFT(n_i,p_j)$ value using insertion-based scheduling policy7: $O_{EFT}(n_i,P_j)=EFT(n_i,p_j)+OCT(t_i,p_k)$8: end for9: Assign task $n_i$ to the processor $p_j$ that minimize $O_{EFT}$ of task $n_i$10: Update ready-list11: end while 1：计算出每个任务的$rank_{oct}$ 2：初始化就绪队列，将entry 任务加入到就绪队列 3-11：循环遍历就绪队列，直到就绪队列为空： ​ 从就绪队列中选取$rank_{oct}$最大的就绪任务 ​ 计算任务在每个处理器上的EFT,进而计算$O_{EFT}(n_i,p_j)$,选取计算值最小的处理器。（注：计算EFT时，前驱结点已固定到处理器上。） ​ 更新就绪队列。 4.2.2 时间复杂度 $O(v^2 p)$","link":"/2021/04/15/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"title":"剑指offer67 把字符串转换成整数【字符串】","text":"题目描述写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路方法一：遍历+状态转移 通过设置状态来判断已遍历字符串为什么状态，比如f为 判断是否为数字开始，如果出现-、+、数字则代表已开始表示数字。 flag表示正负数 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public int strToInt(String str) { int len=str.length(); int i=0; int res=0; int flag=1; int num=0; boolean f=false; while(i&lt;len){ if(str.charAt(i)==' '){ if(f){//判断是否出现+、-、数字 return res*flag; } }else if(str.charAt(i)=='-'){ if(f){ return res*flag; } flag=-1; f=true; }else if(str.charAt(i)=='+'){ if(f){ return res*flag; } flag=1; f=true; } else{ if((str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9')){//判断是否为数字 f=true; num=str.charAt(i)-'0'; if(res&gt;Integer.MAX_VALUE/10||(res==Integer.MAX_VALUE/10&amp;&amp;num&gt;=8)){ if(flag==-1){ return Integer.MIN_VALUE; }else{ return Integer.MAX_VALUE; } } res=res*10+num; }else{ break; } } i+=1;//字符串下标右移 } return res*flag; }} 复杂度分析 时间复杂度：O(n) 空间复杂度：O(1) 资料 https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/","link":"/2021/06/06/%E5%89%91%E6%8C%87offer67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"}],"tags":[{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"斐波那契","slug":"斐波那契","link":"/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"快速幂","slug":"快速幂","link":"/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"有待完善","slug":"有待完善","link":"/tags/%E6%9C%89%E5%BE%85%E5%AE%8C%E5%96%84/"},{"name":"迭代","slug":"迭代","link":"/tags/%E8%BF%AD%E4%BB%A3/"},{"name":"前缀树","slug":"前缀树","link":"/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"分治算法","slug":"分治算法","link":"/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"变动","slug":"变动","link":"/tags/%E5%8F%98%E5%8A%A8/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"剑指offer","slug":"剑指offer","link":"/categories/%E5%89%91%E6%8C%87offer/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"调度","slug":"调度","link":"/categories/%E8%B0%83%E5%BA%A6/"}]}